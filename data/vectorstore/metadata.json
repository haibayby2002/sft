[
  {
    "content": "© Ian Sommerville 2018Agile Software Engineering",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 1,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Software products must be brought to market quickly so rapid software development and delivery is essential.•Virtually all software products are now developed using an agile approach.•Agile software engineering focuses on delivering functionality quickly, responding to changing product speciﬁcations and minimizing development overheads. •A large number of ‘agile methods’ have been developed. •There is no ‘best’ agile method or technique.•It depends on who is using the technique, the development team and the type of product being developedAgile software engineering\n\u00002",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 2,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Plan-driven development evolved to support the engineering of large, long-lifetime systems (such as aircraft control systems) where teams may be geographically dispersed and work on the software for several years.•This approach is based on controlled and rigorous software development processes that include detailed project planning, requirements speciﬁcation and analysis and system modelling.•However, plan-driven development involves signiﬁcant overheads and documentation and it does not support the rapid development and delivery of software.•Agile methods were developed in the 1990s to address this problem. •These methods focus on the software rather than its documentation, develop software in a series of increments and aim to reduce process bureaucracy as much as possible.Agile methods\n\u00003",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 3,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringWe are uncovering better ways of developing software by doing it and helping others to do it. Through this work, we have come to value:- individuals and interactions over processes and tools;- working software over comprehensive documentation;- customer collaboration over contract negotiation;- responding to change over following a plan.While there is value on the items on the right, we value the items on the left more.Table 2.1 The agile manifesto\n\u00004",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 4,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•All agile methods are based around incremental development and delivery. •Product development focuses on the software features, where a feature does something for the software user.•With incremental development, you start by prioritizing the features so that the most important features are implemented ﬁrst. •You only deﬁne the details of the feature being implemented in an increment. •That feature is then implemented and delivered. •Users or surrogate users can try it out and provide feedback to the development team. You then go on to deﬁne and implement the next feature of the system.Incremental development\n\u00005",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 5,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.1 Incremental development\n\u00006Figure 2.1 Incremental developmentProduct feature listIf all features are complete, deliver system releaseChoose features to be included in incrementRefine feature descriptionsDeliver system incrementIntegrate feature into systemImplement andtest feature",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 6,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringChoose features to be included in an increment Using the list of features in the planned product, select those features that can be implemented in the next product increment.Reﬁne feature descriptions Add detail to the feature descriptions so that the team have a common understanding of each feature and there is sufﬁcient detail to begin implementation.Implement and test Implement the feature and develop automated tests for that feature that show that its behaviour is consistent with its description.  Integrate feature and test Integrate the developed feature with the existing system and test it to check that it works in conjunction with other features.Deliver system increment Deliver the system increment to the customer or product manager for checking and comments. If enough features have been implemented, release a version of the system for customer use.Table 2.2 Incremental development activities\n\u00007",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 7,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringInvolve the customer Involve customers closely with the software development team. Their role is to provide and prioritize new system requirements and to evaluate each increment of the system. Embrace change Expect the features of the product and the details of these features to change as the development team and the product manager learn more about it. Adapt the software to cope with changes as they are made.Develop and deliver incrementally Always develop software products in increments. Test and evaluate each increment as it is developed and feed back required changes to the development team.   Table 2.3 Agile development principles\n\u00008",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 8,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringMaintain simplicity Focus on simplicity in both the software being developed and in the development process. Wherever possible, do what you can to eliminate complexity from the system.Focus on people, not things Trust the development team and do not expect everyone to always do the development process in the same way. Team members should be left to develop their own ways of working without being limited by prescriptive software processes.Table 2.3 Agile development principles\n\u00009",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 9,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•The most inﬂuential work that has changed software development culture was the development of Extreme Programming (XP). •The name was coined by Kent Beck in 1998 because the approach was developed by pushing recognized good practice, such as iterative development, to ‘extreme’ levels.•Extreme programming focused on 12 new development techniques that were geared to rapid, incremental software development, change and delivery.•Some of these techniques are now widely used; others have been less popular.•The most widely used XP techniques (highlighted in red on the following slide) are explained elsewhere in the book.Extreme programming\n\u000010",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 10,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.2 Extreme programming practices\n\u000011Test-firstdevelopmentRefactoring\nPair programmingSimpledesignOn-sitecustomerSustainablepaceContinuousintegrationSmallreleasesIncrementalplanningCollectiveownershipExtremeprogrammingFigure 2.2 Extreme programming practices",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 11,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringIncremental planning/user stories There is no ‘grand plan’ for the system. Instead, what needs to be implemented (the requirements) in each increment are established in discussions with a customer representative. The requirements are written as user stories. The stories to be included in a release are determined by the time available and their relative priority. Small releases The minimal useful set of functionality that provides business value is developed ﬁrst. Releases of the system are frequent and incrementally add functionality to the previous release.Test-driven development  Instead of writing code then tests for that code, developers write the tests ﬁrst. This helps clarify what the code should actually do and that there is always a ‘tested’ version of the code available. An automated unit test framework is used to run the tests after every change. New code should not ‘break’ code that has already been implemented.Table 2.4 Widely adopted XP practices\n\u000012",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 12,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringContinuous integration As soon as the work on a task is complete, it is integrated into the whole system and a new version of the system is created. All unit tests from all developers are run automatically and must be successful before the new version of the system is accepted.Refactoring Refactoring means improving the structure, readability, efﬁciency and security of a program. All developers are expected to refactor the code as soon as potential code improvements are found. This keeps the code simple and maintainable.Table 2.4 Widely adopted XP practices\n\u000013",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 13,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Software company managers need information that will help them understand how much it costs to develop a software product, how long it will take and when the product can be brought to market.•Plan-driven development provides this information through long-term development plans that identify deliverables - items the team will deliver and when these will be delivered.•Plans always change so anything apart from short-term plans are unreliable.•Scrum is an agile method that provides a framework for agile project organization and planning. It does not mandate any speciﬁc technical practices. Scrum\n\u000014",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 14,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringProduct The software product that is being developed by the Scrum team.Product owner A team member who is responsible for identifying product features and attributes. They review work done and help to test the product.Product backlog A to-do list of items such as bugs, features and product improvements that the Scrum team have not yet completed.Development team A small self-organising team of ﬁve to eight people who are responsible for developing the product.Sprint  A short period, typically two to four weeks, when a product increment is developed.Table 2.5 Scrum terminology\n\u000015",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 15,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringScrum A daily team meeting where progress is reviewed and work to be done that day as discussed and agreed.ScrumMaster A team coach who guides the team in the effective use of Scrum.Potentially shippable product increment The output of a sprint which should be of high enough quality to be deployed for customer use.Velocity An estimate of how much work a team can do in a single sprint.Table 2.5 Scrum terminology\n\u000016",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 16,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•The Product Owner is responsible for ensuring that the development team are always focused on the product they are building rather than diverted into technically interesting but less relevant work. •In product development, the product manager should normally take on the Product Owner role.   •The ScrumMaster is a Scrum expert whose job is to guide the team in the effective use of the Scrum method. The developers of Scrum emphasize that the ScrumMaster is not a conventional project manager but is a coach for the team. They have authority within the team on how Scrum is used. •In many companies that use Scrum, the ScrumMaster also has some project management responsibilities.Key roles in Scrum\n\u000017",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 17,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•In Scrum, software is developed in sprints, which are ﬁxed-length periods (2 - 4 weeks) in which software features are developed and delivered.•During a sprint, the team has daily meetings (Scrums) to review progress and to update the list of work items that are incomplete.•Sprints should produce a ‘shippable product increment’. This means that the developed software should be complete and ready to deploy.Scrum and sprints\n\u000018",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 18,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.3 Scrum cycles\n\u000019ScrumDevelopsoftwareTestsoftwareSelect itemsto implementPlansprintSprintReviewsprintReview product backlogFigure 2.3. Scrum cycles\nProductbacklogShippableproduct incrementSprintbacklogStart",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 19,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.4 The top ﬁve beneﬁts of using Scrum\n\u000020Product\nProgressPeopleUnstable requirements do not hold up progress.The product is broken down into a set of understandable chunks that stakeholders can relate to.\nCustomers see on-time delivery of increments and gain feedback on how the product works. Team communication is improved because everyone can see  everything.ScrumbenefitsFigure 2.4 The top-five benefits of using Scrum\nTrust between customers and developers is established and a positive culture is created.",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 20,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Product backlog This is a to-do list of items to be implemented that is reviewed and updated before each sprint.•Timeboxed sprints Fixed-time (2-4 week) periods in which items from the product backlog are implemented,•Self-organizing teams Self-organizing teams make their own decisions and work by discussing issues and making decisions by consensus. Key Scrum practices\n\u000021",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 21,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•The product backlog is a list of what needs to be done to complete the development of the product. •The items on this list are called product backlog items (PBIs). •The product backlog may include a variety of different items such as product features to be implemented, user requests, essential development activities and desirable engineering improvements.  •The product backlog should always be prioritized so that the items that be implemented ﬁrst are at the top of the list.  Product backlogs\n\u000022",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 22,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering1.  As a teacher, I want to be able to conﬁgure the group of tools that are available to individual classes. (feature)2.  As a parent, I want to be able to view my childrens’ work and the assessments made by their teachers. (feature)3.  As a teacher of young children, I want a pictorial interface for children with limited reading ability. (user request)4. Establish criteria for the assessment of open source software that might be used as a basis for parts of this system. (development activity)5.  Refactor user interface code to improve understandability and performance. (engineering improvement)6.  Implement encryption for all personal user data. (engineering improvement)Table 2.6 Examples of product backlog items\n\u000023",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 23,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringReady for consideration These are high-level ideas and feature descriptions that will be considered for inclusion in the product. They are tentative so may radically change or may not be included in the ﬁnal product.Ready for reﬁnement The team has agreed that this is an important item that should be implemented as part of the current development. There is a reasonably clear deﬁnition of what is required. However, work is needed to understand and reﬁne the item.Ready for implementation The PBI has enough detail for the team to estimate the effort involved and to implement the item. Dependencies on other items have been identiﬁed.Table 2.7 Product backlog item states\n\u000024",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 24,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.5 Product backlog activities\n\u000025Figure 2.5 Product backlog activitiesPRODUCT BACKLOG\nCreationRefinementEstimationPBI 1PBI 2PBI 3PBI 5PBI 4PBI 4PBI 1.1PBI 1.2PBI 3EPBI 2EPrioritizationCreationPBI 6PBI 5REVISEDPRODUCT BACKLOG",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 25,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Reﬁnement  Existing PBIs are analysed and reﬁned to create more detailed PBIs. This may lead to the creation of new product backlog items.•Estimation The team estimate the amount of work required to implement a PBI and add this assessment to each analysed PBI.•Creation  New items are added to the backlog. These may be new features suggested by the product manager, required feature changes, engineering improvements, or process activities such as the assessment of development tools that might be used.•Prioritization The product backlog items are reordered to take new information and changed circumstances into account.•Product backlog activities\n\u000026",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 26,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Effort required•This may be expressed in person-hours or person-days i.e. the number of hours or days it would take one person to implement that PBI. This is not the same as calendar time. Several people may work on an item, which may shorten the calendar time required.  •Story points•Story points are an arbitrary estimate of the effort involved in implementing a PBI, taking into account the size of the task, its complexity, the technology that may be required and the ‘unknown’ characteristics of the work. •They were derived originally by comparing user stories, but they can be used for estimating any kind of PBI. •Story points are estimated relatively. The team agree on the story points for a baseline task and other tasks are estimated by comparison with this e.g. more/less complex, larger/smaller etc.  PBI estimation metrics\n\u000027",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 27,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Products are developed in a series of sprints, each of which delivers an increment of the product or supporting software. •Sprints are short duration activities (1-4 weeks) and take place between a deﬁned start and end date. Sprints are timeboxed, which means that development stops at the end of a sprint whether or not the work has been completed.•During a sprint, the team work on the items from the product backlog.Timeboxed sprints\n\u000028",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 28,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.6 Beneﬁts of using timeboxed sprints\n\u000029Demonstrable progress\nProblem discoveryWork planningThere is a tangible output (usually a software demonstrator) that can be delivered at the end of every sprint. \nIf errors and omissions are discovered the rework required is limited to the duration of a sprint.The team develops an understand-ing of how much work they can do in a fixed time period. Time-boxingbenefitsFigure 2.6 Benefits of using timeboxed sprints",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 29,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Sprint planning  Work items to be completed in that sprint are selected and, if necessary, reﬁned to create a sprint backlog. This should not last more than a day at the beginning of the sprint.•Sprint execution The team work to implement the sprint backlog items that have been chosen for that sprint. If it is impossible to complete all of the sprint backlog items, the sprint is not extended. The unﬁnished items are returned to the product backlog and queued for a future sprint.•Sprint reviewing The work done in the sprint is reviewed by the team and (possibly) external stakeholders. The team reﬂect on what went well and what went wrong during the sprint with a view to improving their work process.Sprint activities\n\u000030",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 30,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.7 Sprint activities\n\u000031Sprint planningSprint reviewSprint backlogFigure 2.7 Sprint activities\nScrumDevelopsoftwareIntegrateSprint executionSprint backlog",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 31,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering• Establish an agreed sprint goal•Sprint goals may be focused on software functionality, support or performance and reliability,.•Decide on the list of items from the product backlog that should be implemented•Create a sprint backlog. •This is a more detailed version of the product backlog that records the work to be done during the sprintSprint planning\n\u000032",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 32,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.8 Sprint goals\n\u000033Functional\nSupportPerformance and reliabilityImplement user roles so that a user can select their role when they login to the system\nDevelop analytics that maintain information about the time users spend using each feature of the system.Ensure that the login response time is less than 10 seconds for all users where there are up to 2000 simultaneous login connections.SprintgoalsFigure 2.8 Sprint goals",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 33,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•In a sprint plan, the team decides which items in the product backlog should be implemented during that sprint.•Key inputs are the effort estimates associated with PBIs and the team’s velocity•The output of the sprint planning process is a sprint backlog.•The sprint backlog is a breakdown of PBIs to show the what is involved in implementing the PBIs chosen for that sprint.•During a sprint, the team have daily meetings (scrums) to coordinate their work.Sprint planning\n\u000034",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 34,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringA scrum is a short, daily meeting that is usually held at the beginning of the day. During a scrum, all team members share information, describe their progress since the previous day’s scrum, problems that have arisen and plans for the coming day. This means that everyone on the team knows what is going on and, if problems arise, can re-plan short-term work to cope with them.  Scrum meetings should be short and focused. To dissuade team members from getting involved in long discussions, they are sometimes organized as ‘stand-up’ meetings where there are no chairs in the meeting room.During a scrum, the sprint backlog is reviewed. Completed items are removed from it. New items may be added to the backlog as new information emerges. The team then decide who should work on sprint backlog items that day.Table 2.8 Scrums\n\u000035",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 35,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Scrum does not suggest the technical agile activities that should be used. However, I think there are two practices that should always be used in a sprint.•Test automation As far as possible, product testing should be automated. You should develop a suite of executable tests that can be run at any time.  •Continuous integration Whenever anyone makes changes to the software components they are developing, these components should be immediately integrated with other components to create a system. This system should then be tested to check for unanticipated component interaction problems. Agile activities\n\u000036",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 36,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringReviewed The code has been reviewed by another team member who has checked that it meets agreed coding standards, is understandable, includes appropriate comments, and has been refactored if necessary.Unit tested All unit tests have been run automatically and all tests have executed  successfully.Integrated The code has been integrated with the project codebase and no integration errors have been reported.Integration tested All integration tests have been run automatically and all tests have executed successfully.Accepted Acceptance tests have been run if appropriate and the product owner or the development team have conﬁrmed that the product backlog item has been completed. Table 2.9 Code completeness checklist\n\u000037",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 37,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•At the end of each sprint, there is a review meeting, which involves the whole team. This meeting:•reviews whether or not the sprint has met its goal. •sets out any new problems and issues that have emerged during the sprint.•is a way for a team to reﬂect on how they can improve the way they work. •The product owner has the ultimate authority to decide whether or not the goal of the print has been achieved. They should conﬁrm that the implementation of the selected product backlog items is complete. •The sprint review should include a process review, in which the team reﬂects on its own way of working and how Scrum has been used.  •The aim is to identify ways to improve and to discuss how to use Scrum more productively. Sprint reviews\n\u000038",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 38,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.9 Self-organizing teams\n\u000039Self-organizingteamFigure 2.9 Self-organizing teamscoordinates the work of the team members by discussing tasks andreaching a consensus onwho should do what.limits the involvement of engineers in external interactions with management and customers.makes its own decisions on schedule and deliverables.",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 39,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•The ideal Scrum team size is between 5 and 8 people. •Teams have to tackle diverse tasks and so usually require people with different skills, such as networking, user experience, database design and so on. •They usually involve people with different levels of experience.•A team of 5-8 people is large enough to be diverse yet small enough to communicate informally and effectively and to agree on the priorities of the team.•The advantage of a self-organizing team is that it can be a cohesive team that can adapt to change. •Because the team rather than individuals take responsibility for the work, they can cope with people leaving and joining the team. •Good team communication means that team members inevitably learn something about each other’s areasTeam size and composition\n\u000040",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 40,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•The developers of Scrum assumed that teams would be co-located. They would work in the same room and could communicate informally. •Daily scrums mean that the team members know what’s been done and what others are doing.  •However, the use of daily scrums as a coordination mechanism is based on two assumptions that are not always correct:•Scrum assumes that the team will be made up of full-time workers who share a workspace. In reality, team members may be part-time and may work in different places. For a student project team, the team members may take different classes at different times.•Scrum assumes that all team members can attend a morning meeting to coordinate the work for the day. However, some team members may work ﬂexible hours (e.g. because of childcare responsibilities) or may work on several projects at the same time.Team coordination\n\u000041",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 41,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•External interactions are interactions that team members have with people outside of the team. •In Scrum, the idea is that developers should focus on development and only the ScrumMaster and Product Owner should be involved in external interactions.•The intention is that the team should be able to work on software development without external interference or distractions.External interactions\n\u000042",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 42,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.10 Managing external interactions\n\u000043External interactions\nScrumMasterProduct ownerFigure 2.10 Managing external interactions\nProduct-focusedexternal interactionsTeam-focusedexternal interactions",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 43,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•In all but the smallest product development companies, there is a need for development teams to report on progress to company management.• A self-organizing team has to appoint someone to take on these responsibilities. •Because of the need to maintain continuity of communication with people outside of the group, rotating these activities around team members is not a viable approach.•The developers of Scrum did not envisage that the ScrumMaster should also have project management responsibilities. •In many companies, however, the ScrumMaster has to take on project management responsibilities.•They know the work going on and are in the best position to provide accurate information and project plans and progress.Project management\n\u000044",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 44,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.11 Project management responsibilities\n\u000045ProjectmanagementReporting\nAdministrationFigure 2.11 Project management responsibilitiesBudgetScheduleRisksProblemsProgress\nFinanceComplianceProcurementLiaisonVacationsAbsenceWork qualityReviewingHiringPeople",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 45,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•The best way to develop software products is to use agile software engineering methods that are geared to rapid product development and delivery.•Agile methods are based around iterative development and the minimization of overheads during the development process.•Extreme programming (XP) is an inﬂuential agile method that introduced agile development practices such as user stories, test-ﬁrst development and continuous integration. These are now mainstream software development activities.•Scrum is an agile method that focuses on agile planning and management. Unlike XP, it does not deﬁne the engineering practices to be used. The development team may use any technical practices that they believe are appropriate for the product being developed.•In Scrum, work to be done is maintained in a product backlog – a list of work items to be completed. Each increment of the software implements some of the work items from the product backlog.Key points 1\n\u000046",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 46,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Sprints are ﬁxed-time activities (usually 2–4 weeks) where a product increment is developed. Increments should be ‘potentially shippable’ i.e. they should not need further work before they are delivered.•A self-organizing team is a development team that organizes the work to be done by discussion and agreement amongst team members.•Scrum practices such as the product backlog, sprints and self-organizing teams can be used in any agile development process, even if other aspects of Scrum are not used.Key points 2\n\u000047",
    "metadata": {
      "deck_id": 16,
      "slide_id": 32,
      "page_number": 47,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018DevOps and Code Management",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 1,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•Traditionally, separate teams were responsible software development, software release and software support. •The development team passed over a ‘ﬁnal’ version of the software to a release team. This team then built a release version, tested this and prepared release documentation before releasing the software to customers. •A third team was responsible for providing customer support.• The original development team were sometimes also responsible for implementing software changes. •Alternatively, the software may have been maintained by a separate ‘maintenance team’.Software support\n\u00002",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 2,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.1 Development, release and support\n\u00003DevelopmentTested softwareready for releaseReleaseDeployed softwareready for useSupportProblem and bugreportsFigure 10.1 Development, release and support",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 3,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•There are inevitable delays and overheads in the traditional support model. •To speed up the release and support processes, an alternative approach called DevOps (Development+Operations) has been developed.•Three factors led to the development and widespread adoption of DevOps:•Agile software engineering reduced the development time for software, but the traditional release process introduced a bottleneck between development and deployment.  •Amazon re-engineered their software around services and introduced an approach in which a service was developed and supported by the same team. Amazon’s claim that this led to signiﬁcant improvements in reliability was widely publicized.•It became possible to release software as a service, running on a public or private cloud. Software products did not have to be released to users on physical media or downloads.DevOps\n\u00004",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 4,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.2 DevOps\n\u00005\nDevelopmentDeploymentSupportFigure 10.2 Devops\nMulti-skilled DevOps team",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 5,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementEveryone is responsible for everything All team members have joint responsibility for developing, delivering and supporting the software.Everything that can be automated should be automated All activities involved in testing, deployment and support should be automated if it is possible to do so. There should be mimimal manual involvement in deploying software.Measure ﬁrst, change later DevOps should be driven by a measurement program where you collect data about the system and its operation. You then use the collected data to inform decisions about changing DevOps processes and tools.Table 10.1 DevOps principles\n\u00006",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 6,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFaster deployment Software can be deployed to production more quickly because communication delays between the people involved in the process are dramatically reduced.Reduced risk The increment of functionality in each release is small so there is less chance of feature interactions and other changes causing system failures and outages.Faster repair DevOps teams work together to get the software up and running again as soon as possible. There is no need to discover which team were responsible for the problem and to wait for them to ﬁx it.More productive teams DevOps teams are happier and more productive than the teams involved in the separate activities. Because team members are happier, they are less likely to leave to ﬁnd jobs elsewhere.Table 10.2 Beneﬁts of DevOps\n\u00007",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 7,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•During the development of a software product, the development team will probably create tens of thousands of lines of code and automated tests. •These will be organized into hundreds of ﬁles. Dozens of libraries may be used, and several, different programs may be involved in creating and running the code. •Code management is a set of software-supported practices that is used to manage an evolving codebase. •You need code management to ensure that changes made by different developers do not interfere with each other, and to create different product versions. •Code management tools make it easy to create an executable product from its source code ﬁles and to run automated tests on that product.Code management\n\u00008",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 8,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementAlice and Bob worked for a company called FinanceMadeSimple and were team members involved in developing a personal ﬁnance product. Alice discovered a bug in a module called TaxReturnPreparation. The bug was that a tax return was reported as ﬁled but, sometimes, it was not actually sent to the tax ofﬁce. She edited the module to ﬁx the bug. Bob was working on the user interface for the system and was also working on TaxReturnPreparation. Unfortunately, he took a copy before Alice had ﬁxed the bug and, after making his changes, he saved the module. This overwrote Alice’s changes but she was not aware of this. The product tests did not reveal the bug as it was an intermittent failure that depended on the sections of the tax return form that had been completed. The product was launched with the bug. For most users, everything worked OK. However, for a small number of users, their tax returns were not ﬁled and they were ﬁned by the revenue service. The subsequent investigation showed the software company was negligent. This was widely publicised and, as well as a ﬁne from the tax authorities,  users lost conﬁdence in the software. Many switched to a rival product. FinanceMade Simple failed and both Bob and Alice lost their jobs. Table 10.3 A code management problem\n\u00009",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 9,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•Source code management, combined with automated system building, is essential for professional software engineering. •In companies that use DevOps, a modern code management system is a fundamental requirement for ‘automating everything’. •Not only does it store the project code that is ultimately deployed, it also stores all other information that is used in DevOps processes. •DevOps automation and measurement tools all interact with the code management systemCode management and DevOps\n\u000010",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 10,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.3 Code management and Devops\n\u000011Branching and mergingSave andretrieveversionsDevOps automationContinuousintegrationCode management systemContinuousdeploymentContinuousdeliveryInfrastructureas code\nDevOps measurementReportgenerationDataanalysisDatacollectionFigure 10.3 Code management and DevOps\nCoderepositoryTransfer code to/from developer’s filestoreRecoverversioninformation",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 11,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•Code management systems provide a set of features that support four general areas:•Code transfer Developers take code into their personal ﬁle store to work on it then return it to the shared code management system.•Version storage and retrieval Files may be stored in several different versions and speciﬁc versions of these ﬁles can be retrieved.•Merging and branching Parallel development branches may be created for concurrent working. Changes made by developers in different branches may be merged.•Version information Information about the different versions maintained in the system may be stored and retrievedCode management fundamentals\n\u000012",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 12,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•All source code management systems have the general form shown in Figure 10.3. with a shared repository and a set of features to manage the ﬁles in that repository:•All source code ﬁles and ﬁle versions are stored in the repository, as are other artefacts such as conﬁguration ﬁles, build scripts, shared libraries and versions of tools used. •The repository includes a database of information about the stored ﬁles such as version information, information about who has changed the ﬁles, what changes were made at what times, and so on.•Files can be transferred to and from the repository and information about the different versions of ﬁles and their relationships may be updated. •Speciﬁc versions of ﬁles and information about these versions can always be retrieved from the repository.Code repository\n\u000013",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 13,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementVersion and release identiﬁcation Managed versions of a code ﬁle are uniquely identiﬁed when they are submitted to the system and can be retrieved using their identiﬁer and other ﬁle attributes.Change history recording The reasons why changes to a code ﬁle have been made are recorded and maintained.  Independent development Several developers can work on the same code ﬁle at the same time. When this is submitted to the code management system, a new version is created so that ﬁles are never overwritten by later changes.Project support All of the ﬁles associated with a project may be checked out at the same time.There is no need to check out ﬁles one at a time.Storage management The code management system includes efﬁcient storage mechanisms so that it doesn’t keep multiple copies of ﬁles that have only small differences.Table 10.4 Features of code management systems\n\u000014",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 14,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•In 2005, Linus Torvalds, the developer of Linux, revolutionized source code management by developing a distributed version control system (DVCS) called Git to manage the code of the Linux kernel. •This was geared to supporting large-scale open source development. It took advantage of the fact that storage costs had fallen to such an extent that most users did not have to be concerned with local storage management. •Instead of only keeping the copies of the ﬁles that users are working on, Git maintains a clone of the repository on every user’s computer Git\n\u000015",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 15,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.5 Repository cloning in Git\n\u000016Shared Git repositoryMaster branchF1  F2  F3  F4  F5  F6  F7  F8  F9  F10  F11  F12  F13  F14  F15  F16  F17  F18  F19  F20  F21  F22 F23  F24  F25  F26  F27Commit and branch informationBranch 1Branch 2F7  F9  F21F2  F3\nCloneMaster branchF1  F2  F3  F4  F5  F6  F7  F8  F9  F10  F11  F12  F13  F14  F15  F16  F17  F18  F19  F20  F21  F22 F23  F24  F25  F26  F27Commit and branch informationFigure 10.5 Repository cloning in Git\nAlice’s repository",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 16,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•Resilience•Everyone working on a project has their own copy of the repository. If the shared repository is damaged or subjected to a cyberattack, work can continue, and the clones can be used to restore the shared repository. People can work ofﬂine if they don’t have a network connection.•Speed•Committing changes to the repository is a fast, local operation and does not need data to be transferred over the network. •Flexibility•Local experimentation is much simpler. Developers can safely experiment and try different approaches without exposing these to other project members. With a centralized system, this may only be possible by working outside the code management system.•Beneﬁts of distributed code management\n\u000017",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 17,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.6 Git repositories\n\u000018GithubFigure 10.6 Git repositories\nRP1RP2RP3RP4Project 1Project 2\nProject 3Project 4RP1aRP1bRP1dRP1cRP2pRP2rRP2a\nRP3aRP3bRP3fRP3cRP4jRP4k",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 18,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•Branching and merging are fundamental ideas that are supported by all code management systems. •A branch is an independent, stand-alone version that is created when a developer wishes to change a ﬁle. •The changes made by developers in their own branches may be merged to create a new shared branch. •The repository ensures that branch ﬁles that have been changed cannot overwrite repository ﬁles without a merge operation.•If Alice or Bob make mistakes on the branch they are working on, they can easily revert to the master ﬁle. •If they commit changes, while working, they can revert to earlier versions of the work they have done. When they have ﬁnished and tested their code, they can then replace the master ﬁle by merging the work they have done with the master branchBranching and merging\n\u000019",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 19,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.7 Branching and merging\n\u000020MergeFigure 10.7 Branching and mergingAlice\nBobFeature experiment branch\nBug fix branchMaster branch",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 20,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•By using DevOps with automated support, you can dramatically reduce the time and costs for integration, deployment and delivery.•Everything that can be, should be automated is a fundamental principle of DevOps. •As well as reducing the costs and time required for integration, deployment and delivery, process automation also makes these processes more reliable and reproducible. •Automation information is encoded in scripts and system models that can be checked, reviewed, versioned and stored in the project repository.DevOps automation\n\u000021",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 21,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementContinuous integration Each time a developer commits a change to the project’s master branch, an  executable version of the system is built and tested.Continuous delivery A simulation of the product’s operating environment is created and the executable software version is tested.Continuous deployment A new release of the system is made available to users every time a change is made to the master branch of the software.Infrastructure as code Machine-readable models of the infrastructure (network, servers, routers, etc.) on which the product executes are used by conﬁguration management tools to build the software’s execution platform.  The software to be installed, such as compilers and libraries and a DBMS, are included in the infastructure model.Figure 10.5 Aspects of DevOps automation\n\u000022",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 22,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•System integration (system building) is the process of gathering all of the elements required in a working system, moving them into the right directories, and putting them together to create an operational system. •Typical activities that are part of the system integration process include:•Installing database software and setting up the database with the appropriate schema.•Loading test data into the database.•Compiling the ﬁles that make up the product.•Linking the compiled code with the libraries and other components used.•Checking that external services used are operational. •Deleting old conﬁguration ﬁles and moving conﬁguration ﬁles to the correct locations.•Running a set of system tests to check that the integration has been successful.System integration\n\u000023",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 23,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•Continuous integration simply means that an integrated version of the system is created and tested every time a change is pushed to the system’s shared repository. •On completion of the push operation, the repository sends a message to an integration server to build a new version of the product•The advantage of continuous integration compared to less frequent integration is that it is faster to ﬁnd and ﬁx bugs in the system. •If you make a small change and some system tests then fail, the problem almost certainly lies in the new code that you have pushed to the project repo. •You can focus on this code to ﬁnd the bug that’s causing the problem. Continuous integration\n\u000024",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 24,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.9 Continuous integration\n\u000025GETCOMPILE AND BUILDTESTExecutablesystemFigure 10.9 Continuous integrationSource code filesfrom code management\nLibrariesConfigurationfilesDatabasefilesExecutabletestsDeployablesystem\nTrigger from repo",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 25,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•In a continuous integration environment, developers have to make sure that they don’t ‘break the build’. •Breaking the build means pushing code to the project repository which, when integrated, causes some of the system tests to fail. •If this happens to you, your priority should be to discover and ﬁx the problem so that normal development can continue. •To avoid breaking the build, you should always adopt an ‘integrate twice’ approach to system integration. •You should integrate and test on your own computer before pushing code to the project repository to trigger the integration server Breaking the build\n\u000026",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 26,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.10 Local integration\n\u000027Make changesto codeCommit changesto local repoPull changes to master branchMerge masterwith local repoCompile andbuild systemTestsystemExecutablesystemTest failurePush codeto project repoTestsuccessExecutabletestsFigure 10.10 Local integrationFrom project repo",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 27,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•Continuous integration is only effective if the integration process is fast and developers do not have to wait for the results of their tests of the integrated system. •However, some activities in the build process, such as populating a database or compiling hundreds of system ﬁles, are inherently slow. •It is therefore essential to have an automated build process that minimizes the time spent on these activities. •Fast system building is achieved using a process of incremental building, where only those parts of the system that have been changed are rebuiltSystem building\n\u000028",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 28,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.11 A dependency model\n\u000029Test executionProgram object code filesFigure 10.11 A dependency modelTest sourcecode filesProgram source code filesTest object code filesdepends ondepends on",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 29,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•Figure 10.11 is a dependency model that shows the dependencies for test execution. •The upward-pointing arrow means ‘depends on’ and shows the information required to complete the task shown in the rectangle at the base of the model. •Running a set of system tests depends on the existence of executable object code for both the program being tested and the system tests. •In turn, these depend on the source code for the system and the tests that are compiled to create the object code. •Figure 10.12 is a lower-level dependency model that shows the dependencies involved in creating the object code for a source code ﬁles called Mycode.Dependencies\n\u000030",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 30,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.12 File dependencies\n\u000031Mycode (compiled)Mycode (source)Lib 2Figure 10.12 File dependenciesClassdef (compiled)Lib 2",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 31,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•An automated build system uses the speciﬁcation of dependencies to work out what needs to be done. It uses the ﬁle modiﬁcation timestamp to decide if a source code ﬁle has been changed. •The modiﬁcation date of the compiled code is after the modiﬁcation date of the source code. The build system infers that no changes have been made to the source code and does nothing.•The modiﬁcation date of the compiled code is before the modiﬁcation date of the compiled code. The build system recompiles the source and replaces the existing ﬁle of compiled code with an updated version.•The modiﬁcation date of the compiled code is after the modiﬁcation date of the source code. However, the modiﬁcation date of Classdef is after the modiﬁcation date of the source code of Mycode. Therefore, Mycode has to be recompiled to incorporate these changes.\n\u000032",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 32,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•Continuous integration means creating an executable version of a software system whenever a change is made to the repository. The CI tool builds the system and runs tests on your development computer or project integration server. •However, the real environment in which software runs will inevitably be different from your development system. •When your software runs in its real, operational environment bugs may be revealed that did not show up in the test environment.•Continuous delivery means that, after making changes to a system, you ensure that the changed system is ready for delivery to customers. •This means that you have to test it in a production environment to make sure that environmental factors do not cause system failures or slow down its performance.Continuous delivery and deployment\n\u000033",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 33,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.13 Continuous delivery and deployment\n\u000034Continuous deliveryTestedsystemConfigure test serverInstall systemon test serverRun acceptancetestsInstall software onproduction serversSwitch operation to new softwareContinuous deploymentAll tests passFigure 10.13 Continuous delivery and deploymentRequiredsoftwareTestset",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 34,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•After initial integration testing, a staged test environment is created. •This is a replica of the actual production environment in which the system will run. •The system acceptance tests, which include functionality, load and performance tests, are then run to check that the software works as expected. If all of these tests pass, the changed software is installed on the production servers.•To deploy the system, you then momentarily stop all new requests for service and leave the older version to process the outstanding transactions. •Once these have been completed, you switch to the new version of the system and restart processing.The deployment pipeline\n\u000035",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 35,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementReduced costs If you use continuous deployment, you have no option but to invest in a completely automated deployment pipeline. Manual deployment is a time-consuming and error-prone process. Setting up an automated system is expensive and time-consuming but you can recover these costs quickly if you make regular updates to your product.Faster problem solving If a problem occurs, it will probably only affect a small part of the system and it will be obvious what the source of that problem is. If you bundle many changes into a single release, ﬁnding and ﬁxing problems is more difﬁcult.Faster customer feedback You can deploy new features when they are ready for customer use. You can ask them for feedback on these features and use this feedback to identify improvements that you need to make.A/B testing This is an option if you have a large customer base and use several servers for deployment. You can deploy a new version of the software on some servers and leave the older version running on others. You then use the load balancer to divert some customers to the new version while others use the older version. You can then measure and assess how new features are used to see if they do what you expect.Figure 10.6 Beneﬁts of continuous deployment\n\u000036",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 36,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•In an enterprise environment, there are usually many different physical or virtual servers (web servers, database servers, ﬁle servers, etc.) that do different things. These have different conﬁgurations and run different software packages. •It is therefore difﬁcult to keep track of the software installed on each machine.•The idea of infrastructure as code was proposed as a way to address this problem. Rather than manually updating the software on a company’s servers, the process can be automated using a model of the infrastructure written in a machine-processable language. •Conﬁguration management (CM) tools such as Puppet and Chef can automatically install software and services on servers according to the infrastructure deﬁnitionInfrastructure as code\n\u000037",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 37,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.14 Infrastructure as code\n\u000038S1: ......       ......S2: ......       ......S3, S4:        ......       ......InfrastructuredefinitionCM toolSoftware to beinstalledServersS1S2S3Figure 10.14 Infrastructure as code\nS4",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 38,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•Deﬁning your infrastructure as code and using a conﬁguration management system solves two key problems of continuous deployment.•Your testing environment must be exactly the same as your deployment environment. If you change the deployment environment, you have to mirror those changes in your testing environment.•When you change a service, you have to be able to roll that change out to all of your servers quickly and reliably. If there is a bug in your changed code that affects the system’s reliability, you have to be able to seamlessly roll back to the older system.•The business beneﬁts of deﬁning your infrastructure as code are lower costs of system management and lower risks of unexpected problems arising when infrastructure changes are implemented. Beneﬁts of infrastructure as code\n\u000039",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 39,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementVisibility Your infrastructure is deﬁned as a stand-alone model that can be read, discussed, understood and reviewed by the whole DevOps team.Reproducability Using a conﬁguration management tool means that the installation tasks will always be run in the same sequence so that the same environment is always created. You are not reliant on people remembering the order that they need to do things.Reliability The complexity of managing a complex infrastructure means that system administrators often make simple mistakes, especially when the same changes have to be made to several servers. Automating the process avoids these mistakes.Recovery Like any other code, your infrastructure model can be versioned and stored in a code management system. If infrastructure changes cause problems you can easily revert to an older version and reinstall the environment that you know works.Table 10.7 Characteristics of infrastructure as code\n\u000040",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 40,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•A container provides a stand-alone execution environment running on top of an operating system such as Linux. •The software installed in a Docker container is speciﬁed using a Dockerﬁle, which is, essentially, a deﬁnition of your software infrastructure as code. •You build an executable container image by processing the Dockerﬁle. •Using containers makes it very simple to provide identical execution environments. •For each type of server that you use, you deﬁne the environment that you need and build an image for execution. You can run an application container as a test system or as an operational system; there is no distinction between them. •When you update your software, you rerun the image creation process to create a new image that includes the modiﬁed software. You can then start these images alongside the existing system and divert service requests to them.Containers\n\u000041",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 41,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•After you have adopted DevOps, you should try to continuously improve your DevOps process to achieve faster deployment of better-quality software.•There are four types of software development measurement:•Process measurement You collect and analyse data about your development, testing and deployment processes.•Service measurement You collect and analyse data about the software’s performance, reliability and acceptability to customers. •Usage measurement You collect and analyse data about how customers use your product.•Business success measurement You collect and analyse data about how your product contributes to the overall success of the business.DevOps measurement\n\u000042",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 42,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•As far as possible, the DevOps principle of automating everything should be applied to software measurement. •You should instrument your software to collect data about itself and you should use a monitoring system, as I explained in Chapter 6, to collect data about your software’s performance and availability. •Some process measurements can also be automated. •However, there are problems in process measurement because people are involved. They work in different ways, may record information differently and are affected by outside inﬂuences that affect the way they work.•Automating measurement\n\u000043",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 43,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.15 Metrics used in the DevOps scorecard\n\u000044Figure 10.15 Metrics used in the DevOps scorecardDeploymentfrequencyChangevolume\nDevOpsmetricsLead time fromdevelopment to deploymentPercentage offailed deploymentsMean time to recoveryNumber of customer complaintsAvailabilityPerformancePercentage increasein customer numbersProcess metrics\nService metrics",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 44,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•Payal Chakravarty from IBM suggests a practical approach to DevOps measurement based around a metrics scorecard with 9 metrics:•These are relevant to software that is delivered as a cloud service. They include process metrics and service metrics•For the process metrics, you would like to see decreases in the number of failed deployments, the mean time to recovery after a service failure and the lead time from development to deployment. •You would hope to see increases in the deployment frequency and the number of lines of changed code that are shipped. •For the service metrics, availability and performance should be stable or improving, the number of customer complaints should be decreasing, and the number of new customers should be increasing.Metrics scorecard\n\u000045",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 45,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.16 Metrics trends\n\u000046WeeksAvailabilityDeploymentfrequencyNumber ofcustomercomplaintsFigure 10.16 Metrics trends\n12345",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 46,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code ManagementFigure 10.17 Logging and analysis\n\u000047ExecutingsoftwareLog 2Log 1Log 3LoganalyserMetrics dashboardFigure 10.17 Logging and analysis",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 47,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•DevOps is the integration of software development and the management of that software once it has been deployed for use. The same team is responsible for development, deployment and software support.•The beneﬁts of DevOps are faster deployment, reduced risk, faster repair of buggy code and more productive teams.•Source code management is essential to avoid changes made by different developers interfering with each other.•All code management systems are based around a shared code repository with a set of features that support code transfer, version storage and retrieval, branching and merging and maintaining version information.•Git is a distributed code management system that is the most widely used system for software product development. Each developer works with their own copy of the repository which may be merged with the shared project repository.Key points 1\n\u000048",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 48,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:DevOps and Code Management•Continuous integration means that as soon as a change is committed to a project repository, it is integrated with existing code and a new version of the system is created for testing.•Automated system building tools reduce the time needed to compile and integrate the system by only recompiling those components and their dependents that have changed.•Continuous deployment means that as soon as a change is made, the deployed version of the system is automatically updated. This is only possible when the software product is delivered as a cloud-based service.•Infrastructure as code means that the infrastructure (network, installed software, etc.) on which software executes is deﬁned as a machine-readable model. Automated tools, such as Chef and Puppet, can provision servers based on the infrastructure model.•Measurement is a fundamental principle of DevOps. You may make both process and product measurements. Important process metrics are deployment frequency, percentage of failed deployments, and mean time to recovery from failure.Key points 2\n\u000049",
    "metadata": {
      "deck_id": 18,
      "slide_id": 34,
      "page_number": 49,
      "title": "10. DevOps and Code Management.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/10. DevOps and Code Management.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018Testing",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 1,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•Software testing is a process in which you execute your program using data that simulates user inputs. •You observe its behaviour to see whether or not your program is doing what it is supposed to do. •Tests pass if the behaviour is what you expect. Tests fail if the behaviour differs from that expected.•If your program does what you expect, this shows that for the inputs used, the program behaves correctly. •If these inputs are representative of a larger set of inputs, you can infer that the program will behave correctly for all members of this larger input set.Software testing\n\u00002",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 2,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•If the behaviour of the program does not match the behaviour that you expect, then this means that there are bugs in your program that need to be ﬁxed. •There are two causes of program bugs:•Programming errors You have accidentally included faults in your program code. For example, a common programming error is an ‘off-by-1’ error where you make a mistake with the upper bound of a sequence and fail to process the last element in that sequence. •Understanding errors You have misunderstood or have been unaware of some of the details of what the program is supposed to do. For example, if your program processes data from a ﬁle, you may not be aware that some of this data is in the wrong format, so your program doesn’t include code to handle this.•Program bugs\n\u00003",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 3,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingFunctional testing Test the functionality of the overall system. The goals of functional testing are to discover as many bugs as possible in the implementation of the system and to provide convincing evidence that the system is ﬁt for its intended purpose.User testing Test that the software product is useful to and usable by end-users. You need to show that the features of the system help users do what they want to do with the software. You should also show that users understand how to access the software’s features and can use these features effectively.Performance and load testing Test that the software works quickly and can handle the expected load placed on the system by its users. You need to show that the response and processing time of your system is acceptable to end-users. You also need to demonstrate that your system can handle different loads and scales gracefully as the load on the software increases.Security testing Test that the software maintains its integrity and can protect user information from theft and damage. Table 9.1 Types of testing\n\u00004",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 4,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•Functional testing involves developing a large set of program tests so that, ideally, all of a program’s code is executed at least once. •The number of tests needed obviously depends on the size and the functionality of the application. •For a business-focused web application, you may have to develop thousands of tests to convince yourself that your product is ready for release to customers.•Functional testing is a staged activity in which you initially test individual units of code. You integrate code units with other units to create larger units then do more testing. •The process continues until you have created a complete system ready for release. Functional testing\n\u00005",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 5,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingFigure 9.2 Functional testing\n\u00006FeaturetestingSystemtestingReleasetestingFigure 9.2 Functional testing UnitTestingStart",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 6,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingUnit testing The aim of unit testing is to test program units in isolation. Tests should be designed to execute all of the code in a unit at least once. Individual code units are tested by the programmer as they are developed.Feature testing Code units are integrated to create features. Feature tests should test all aspects of a feature. All of the programmers who contribute code units to a feature should be involved in its testing.System testing Code units are integrated to create a working (perhaps incomplete) version of a system. The aim of system testing is to check that there are no unexpected interactions between the features in the system. System testing may also involve checking the responsiveness, reliability and security of the system. In large companies, a dedicated testing team may be responsible for system testing. In small companies, this is impractical, so product developers are also involved in system testing.Release testing The system is packaged for release to customers and the release is tested to check that it operates as expected. The software may be released as a cloud service or as a download to be installed on a customer’s computer or mobile device. If DevOps is used, then the development team are responsible for release testing otherwise a separate team has that responsibility.Table 9.2 Functional testing processes\n\u00007",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 7,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•As you develop a code unit, you should also develop tests for that code. •A code unit is anything that has a clearly deﬁned responsibility. It is usually a function or class method but could be a module that includes a small number of other functions. •Unit testing is based on a simple general principle:•If a program unit behaves as expected for a set of inputs that have some shared characteristics, it will behave in the same way for a larger set whose members share these characteristics.•To test a program efﬁciently, you should identify sets of inputs (equivalence partitions) that will be treated in the same way in your code. •The equivalence partitions that you identify should not just include those containing inputs that produce the correct values. You should also identify ‘incorrectness partitions’ where the inputs are deliberately incorrect. Unit testing\n\u00008",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 8,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingFigure 9.3 Equivalence partitions\n\u00009Set of all possible inputs5Partition 1, where allinputs share characteristic C1and some share characteristicC2.Partition 2, where all inputs share characteristic C2. Some inputs also share characteristic C1.\nPartition 3, where all inputs share characteristic C3. Some inputs also sharecharacteristic C4.Partition 4 where all inputs share characteristic C4. Some inputs also share characteristics C3 or C5 butnot bothPartition 5 where allinputs share characteristics C4 and C5. None sharecharacteristic C3                                                 Figure 9.3 Equivalence partitions\n1234",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 9,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testingdef namecheck (s):# Checks that a name only includes alphabetic characters, - or # a single quote. Names must be between 2 and 40 characters long# quoted strings and -- are disallowednamex = r\"^[a-zA-Z][a-zA-Z-']{1,39}$\"if re.match (namex, s):if re.search (\"'.*'\", s) or re.search (\"--\", s):return False else:return Trueelse:return False \n\u000010Program 9.1A name checking function",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 10,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingCorrect names 1 The inputs only includes alphabetic characters and are between 2 and 40 characters long.Correct names 2 The inputs only includes alphabetic characters, hyphens or apostrophes and are between 2 and 40 characters long.Incorrect names 1 The inputs are between 2 and 40 characters long but include disallowed characters.Incorrect names 2 The inputs include allowed characters but are either a single character or are more than 40 characters long.Incorrect names 3 The inputs are between 2 and 40 characters long but the ﬁrst character is a hyphen or an apostrophe.Incorrect names 4 The inputs include valid characters, are between 2 and 40 characters long, but include either a double hyphen, quoted text or both.Table 9.3 Equivalence partitions for the name checking function\n\u000011",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 11,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingTest edge cases If your partition has upper and lower bounds (e.g. length of strings, numbers, etc.) choose inputs at the edges of the range.Force errors Choose test inputs that force the system to generate all error messages. Choose test inputs that should generate invalid outputs.Fill buffers Choose test inputs that cause all input buffers to overﬂow.Repeat yourself Repeat the same test input or series of inputs several times.Table 9.4 Unit testing guidelines (1)\n\u000012",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 12,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingOverﬂow and underﬂow If your program does numeric calculations, choose test inputs that cause it to calculate very large or very small numbers.Don’t forget null and zero If your program uses pointers or strings, always test with null pointers and strings. If you use sequences, test with an empty sequence. For numeric inputs, always test with zero.Keep count When dealing with lists and list transformation, keep count of the number of elements in each list and check that these are consistent after each transformation.One is different If your program deals with sequences, always test with sequences that have a single value.Table 9.4 Unit testing guidelines (2)\n\u000013",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 13,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•Features have to be tested to show that the functionality is implemented as expected and that the functionality meets the real needs of users. •For example, if your product has a feature that allows users to login using their Google account, then you have to check that this registers the user correctly and informs them of what information will be shared with Google. •You may want to check that it gives users the option to sign up for email information about your product.•Normally, a feature that does several things is implemented by multiple, interacting, program units. •These units may be implemented by different developers and all of these developers should be involved in the feature testing process. Feature testing\n\u000014",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 14,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•Interaction tests•These test the interactions between the units that implement the feature. The developers of the units that are combined to make up the feature may have different understandings of what is required of that feature. •These misunderstandings will not show up in unit tests but may only come to light when the units are integrated. •The integration may also reveal bugs in program units, which were not exposed by unit testing.•Usefulness tests•These test that the feature implements what users are likely to want. •For example, the developers of a login with Google feature may have implemented an opt-out default on registration so that users receive all emails from a company. They must expressly choose what type of emails that they don’t want. •What might be preferred is an opt-in default so that users choose what types of email they do want to receive.Types of feature test\n\u000015",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 15,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingUser registration As a user, I want to be able to login without creating a new account so that I don’t have to remember another login id and password.Information sharing As a user, I want to know what information you will share with other companies. I want to be able to cancel my registration if I don’t want to share this information.Email choice As a user, I want to be able to choose the types of email that I’ll get from you when I register for an account.Table 9.5 User stories for the sign-in with Google feature\n\u000016",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 16,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingInitial login screen Test that the screen displaying a request for Google account credentials is correctly displayed when a user clicks on the ‘Sign-in with Google’ link. Test that the login is completed if the user is already logged in to Google.Incorrect credentials Test that the error message and retry screen is displayed if the user inputs incorrect Google credentials.Shared information Test that the information shared with Google is displayed, along with a cancel or conﬁrm option.  Test that the registration is cancelled if the cancel option is chosen.Email opt-in Test that the user is offered a menu of options for email information and can choose multiple items to opt-in to emails. Test that the user is not registered for any emails if no options are selected. Table 9.6 Feature tests for sign-in with Google\n\u000017",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 17,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•System testing involves testing the system as a whole, rather than the individual system features. •System testing should focus on four things:•Testing to discover if there are unexpected and unwanted interactions between the features in a system.•Testing to discover if the system features work together effectively to support what users really want to do with the system.•Testing the system to make sure it operates in the expected way in the different environments where it will be used. •Testing the responsiveness, throughput, security and other quality attributes of the system. System and release testing\n\u000018",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 18,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•The best way to systematically test a system is to start with a set of scenarios that describe possible uses of the system and then work through these scenarios each time a new version of the system is created. •Using the scenario, you identify a set of end-to-end pathways that users might follow when using the system. •An end-to-end pathway is a sequence of actions from starting to use the system for the task, through to completion of the task. Scenario-based testing\n\u000019",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 19,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingAndrew and Maria have a two year old son and a four month old daughter. They live in Scotland and they want to have a holiday in the sunshine. However, they are concerned about the hassle of ﬂying with young children. They decide to try a family holiday planner product to help them choose a destination that is easy to get to and that ﬁts in with their childrens’ routines.Maria navigates to the holiday planner website and selects the ‘ﬁnd a destination’ page. This presents a screen with a number of options. She can choose a speciﬁc destination or can choose a departure airport and ﬁnd all destinations that have direct ﬂights from that airport. She can also input the time band that she’d prefer for ﬂights, holiday dates and a maximum cost per person.Edinburgh is their closest departure airport. She chooses ‘ﬁnd direct ﬂights’. The system then presents a list of countries that have direct ﬂights from Edinburgh and the days when these ﬂights operate. She selects France, Italy, Portugal and Spain and requests further information about these ﬂights. She then sets a ﬁlter to display ﬂights that leave on a Saturday or Sunday after 7.30am and arrive before 6pm. She also sets the maximum acceptable cost for a ﬂight. The list of ﬂights is pruned according to the ﬁlter and is redisplayed. Maria then clicks on the ﬂight she wants. This opens a tab in her browser showing a booking form for this ﬂight on the airline’s website.Figure 9.7 Choosing a holiday destination\n\u000020",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 20,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing1. User inputs departure airport and chooses to see only direct ﬂights. User quits.2. User inputs departure airport and chooses to see all ﬂights. User quits.3. User chooses destination country and chooses to see all ﬂights. User quits.4. User inputs departure airport and chooses to see direct ﬂights. User sets ﬁlter specifying departure times and prices. User quits.5. User inputs departure airport and chooses to see direct ﬂights. User sets ﬁlter specifying departure times and prices. User selects a displayed ﬂight and clicks through to airline website. User returns to holiday planner after booking ﬂight.Table 9.8 End-to-end pathways\n\u000021",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 21,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•Release testing is a type of system testing where a system that’s intended for release to customers is tested. •The fundamental differences between release testing and system testing are:•Release testing tests the system in its real operational environment rather than in a test environment. Problems commonly arise with real user data, which is sometimes more complex and less reliable than test data.•The aim of release testing is to decide if the system is good enough to release, not to detect bugs in the system. Therefore, some tests that ‘fail’ may be ignored if these have minimal consequences for most users.•Preparing a system for release involves packaging that system for deployment (e.g. in a container if it is a cloud service) and installing software and libraries that are used by your product. You must deﬁne conﬁguration parameters such as the name of a root directory, the database size limit per user and so on. Release testing\n\u000022",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 22,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•Automated testing is based on the idea that tests should be executable. •An executable test includes the input data to the unit that is being tested, the expected result and a check that the unit returns the expected result. •You run the test and the test passes if the unit returns the expected result. •Normally, you should develop hundreds or thousands of executable tests for a software product.Test automation\n\u000023",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 23,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingFigure 9.4 Automated testing\n\u000024Figure 9.4 Automated testing\nTestrunnerCodebeing testedTestingframeworkFiles of executable tests\nTestreport",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 24,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing# TestInterestCalculator inherits attributes and methods from the class # TestCase in the testing framework unittestclass TestInterestCalculator (unittest.TestCase):# Deﬁne a set of unit tests where each test tests one thing only# Tests should start with test_ and the name should explain what is being testeddef test_zeroprincipal (self):#Arrange - set up the test parametersp = 0; r = 3; n = 31result_should_be = 0#Action - Call the method to be testedinterest = interest_calculator (p, r, n)#Assert - test what should be trueself.assertEqual (result_should_be, interest)def test_yearly_interest (self):#Arrange - set up the test parametersp = 17000; r = 3; n = 365#Action - Call the method to be testedresult_should_be = 270.36interest = interest_calculator (p, r, n)#Assert - test what should be trueself.assertEqual (result_should_be, interest)\u000025Program 9.2 Test methods for an interest calculator",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 25,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•It is good practice to structure automated tests into three parts:•Arrange You set up the system to run the test. This involves deﬁning the test parameters and, if necessary, mock objects that emulate the functionality of code that has not yet been developed.•Action You call the unit that is being tested with the test parameters. •Assert You make an assertion about what should hold if the unit being tested has executed successfully. In Program 9.2, I use AssertEquals, which checks if its parameters are equal.•If you use equivalence partitions to identify test inputs, you should have several automated tests based on correct and incorrect inputs from each partition. Automated tests\n\u000026",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 26,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testingimport unittestfrom RE_checker import namecheckclass TestNameCheck (unittest.TestCase):def test_alphaname (self):self.assertTrue (namecheck ('Sommerville'))def test_doublequote (self):self.assertFalse (namecheck (\"Thisis'maliciouscode'\"))def test_namestartswithhyphen (self):self.assertFalse (namecheck ('-Sommerville'))def test_namestartswithquote (self):self.assertFalse (namecheck (\"'Reilly\"))def test_nametoolong (self):self.assertFalse (namecheck ('Thisisalongstringwithmorethen40charactersfrombeginningtoend'))def test_nametooshort (self):self.assertFalse (namecheck ('S'))def test_namewithdigit (self):self.assertFalse (namecheck('C-3PO'))def test_namewithdoublehyphen (self):self.assertFalse (namecheck ('--badcode'))\u000027Program 9.3 (1) Executable tests for the namecheck function",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 27,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testingdef test_namewithhyphen (self):self.assertTrue (namecheck ('Washington-Wilson'))def test_namewithinvalidchar (self):self.assertFalse (namecheck('Sommer_ville'))def test_namewithquote (self):self.assertTrue (namecheck (\"O'Reilly\"))def test_namewithspaces (self):self.assertFalse (namecheck ('Washington Wilson'))def test_shortname (self):self.assertTrue ('Sx')def test_thiswillfail (self):self.assertTrue (namecheck (\"O Reilly\"))\n\u000028Program 9.3 (2)Executable tests for the namecheck function",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 28,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testingimport unittestloader = unittest.TestLoader()#Find the test ﬁles in the current directorytests = loader.discover('.')#Specify the level of information provided by the test runnertestRunner = unittest.runner.TextTestRunner(verbosity=2)testRunner.run(tests)\n\u000029Program 9.4 Code to run unit tests from ﬁles",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 29,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingFigure 9.5 The test pyramid\n\u000030Unit testsFeature testsSystemtestsIncreased automationReduced costsFigure 9.5 The test pyramid",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 30,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•Generally, users access features through the product’s graphical user interface (GUI). •However, GUI-based testing is expensive to automate so it is best to design your product so that its features can be directly accessed through an API and not just from the user interface. •The feature tests can then access features directly through the API without the need for direct user interaction through the system’s GUI. •Accessing features through an API has the additional beneﬁt that it is possible to re-implement the GUI without changing the functional components of the software.Automated feature testing\n\u000031",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 31,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingFigure 9.6 Feature editing through an API\n\u000032Feature 1Feature 3Feature 4Feature 2APIBrowser or mobile app interfaceFigure 9.6 Feature testing through an APIFeaturetests",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 32,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•System testing, which should follow feature testing, involves testing the system as a surrogate user. •As a system tester, you go through a process of selecting items from menus, making screen selections, inputting information from the keyboard and so on. •You are looking for interactions between features that cause problems, sequences of actions that lead to system crashes and so on.•Manual system testing, when testers have to repeat sequences of actions, is boring and error-prone. In some cases, the timing of actions is important and is practically impossible to repeat consistently. •To avoid these problems, testing tools have been developed that can record a series of actions and automatically replay these when a system is retestedSystem testing\n\u000033",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 33,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingFigure 9.7 Interaction recording and playback\n\u000034System being testedSystem APIInteractionsession recordUser action recordingUser actionplaybackFigure 9.7 Interaction recording and playbackBrowser or mobile app interface",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 34,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•Test-driven development (TDD) is an approach to program development that is based around the general idea that you should write an executable test or tests for code that you are writing before you write the code. •It was introduced by early users of the Extreme Programming agile method, but it can be used with any incremental development approach.•Test-driven development works best for the development of individual program units and it is more difﬁcult to apply to system testing. •Even the strongest advocates of TDD accept that it is challenging to use this approach when you are developing and testing systems with graphical user interfaces.Test-driven development\n\u000035",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 35,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingFigure 9.8 Test-driven development\n\u000036Write code stub thatwill fail testRun all automated testsImplement code thatshould cause failing test to passIdentify partial implementationof functionalityFunctionality completeFunctionalityincompleteRefactor codeif requiredAll tests passIdentify new functionality\nRun all automated testsTest failureFigure 9.8 Test-driven developmentStart",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 36,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingIdentify partial implementation Break down the implementation of the functionality required into smaller mini-units. Choose one of these mini-units for implementation.Write mini-unit tests Write one or more automated tests for the mini-unit that you have chosen for implementation. The mini-unit should pass these tests if it is properly implemented.Write a code stub that will fail test Write incomplete code that will be called to implement the mini-unit. You know this will fail.Run all existing automated tests All previous tests should pass. The test for the incomplete code should fail.Table 9.9 Stages of test-driven development (1)\n\u000037",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 37,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingImplement code that should cause the failing test to pass Write code to implement the mini-unit, which should cause it to operate correctlyRerun all automated tests If any tests fail, your code is probably incorrect. Keep working on it until all tests pass.Refactor code if necessary If all tests pass, you can move on to implementing  the next mini-unit. If you see ways of improving your code, you should do this before the next stage of implementation.Table 9.9 Stages of test-driven development (2)\n\u000038",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 38,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•It is a systematic approach to testing in which tests are clearly linked to sections of the program code. •This means you can be conﬁdent that your tests cover all of the code that has been developed and that there are no untested code sections in the delivered code. In my view, this is the most signiﬁcant beneﬁt of TDD. •The tests act as a written speciﬁcation for the program code. In principle at least, it should be possible to understand what the program does by reading the tests. •Debugging is simpliﬁed because, when a program failure is observed, you can immediately link this to the last increment of code that you added to the system.•It is argued that TDD leads to simpler code as programmers only write code that’s necessary to pass tests. They don’t over-engineer their code with complex features that aren’t needed.Beneﬁts of test-driven development\n\u000039",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 39,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingTDD discourages radical program change I found that I was reluctant to make refactoring decisions that I knew would cause many tests to fail. I tended to avoid radical program change for this reason.I focused on the tests rather than the problem I was trying to solve A basic principle of TDD is that your design should be driven by the tests you have written. I found that I was unconsciously redeﬁning the problem I was trying to solve to make it easier to write tests. This meant that I sometimes didn’t implement important checks, because it was difﬁcult to write tests in advance of their implementation.I spent too much time thinking about implementation details rather than the programming problem Sometimes when programming, it is best to step back and look at the program as a whole rather than focusing on implementation details. TDD encourages a focus on details that might cause tests to pass or fail and discourages large-scale program revisions.It is hard to write ‘bad data’ tests Many problems involving dealing with messy and incomplete data. It is practically impossible to anticipate all of the data problems that might arise and write tests for these in advance. You might argue that you should simply reject bad data but this is sometimes impractical.Table 9.10 My reasons for not using TDD\n\u000040",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 40,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•Security testing aims to ﬁnd vulnerabilities that may be exploited by an attacker and to provide convincing evidence that the system is sufﬁciently secure. •The tests should demonstrate that the system can resist attacks on its availability, attacks that try to inject malware and attacks that try to corrupt or steal users’ data and identity.•Comprehensive security testing requires specialist knowledge of software vulnerabilities and approaches to testing that can ﬁnd these vulnerabilities. Security testing\n\u000041",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 41,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•A risk-based approach to security testing involves identifying common risks and developing tests to demonstrate that the system protects itself from these risks. •You may also use automated tools that scan your system to check for known vulnerabilities, such as unused HTTP ports being left open.•Based on the risks that have been identiﬁed, you then design tests and checks to see if the system is vulnerable. •It may be possible to construct automated tests for some of these checks, but others inevitably involve manual checking of the system’s behaviour and its ﬁles.Risk-based security testing\n\u000042",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 42,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingUnauthorized attacker gains access to a system using authorized credentialsAuthorized individual accesses resources that are forbidden to themAuthentication system fails to detect unauthorized attackerAttacker gains access to database using SQL poisoning attackImproper management of HTTP sessionHTTP session cookies revealed to attackerConﬁdential data are unencryptedEncryption keys are leaked to potential attackersTable 9.11 Examples of security risks\n\u000043",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 43,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•Once you have identiﬁed security risks, you then analyze them to assess how they might arise. For example, for the ﬁrst risk in Table 9.11 (unauthorized attacker) there are several possibilities:•The user has set weak passwords that can be guessed by an attacker.•The system’s password ﬁle has been stolen and passwords discovered by attacker.•The user has not set up two-factor authentication.•An attacker has discovered credentials of a legitimate user through social engineering techniques.•You can then develop tests to check some of these possibilities. •For example, you might run a test to check that the code that allows users to set their passwords always checks the strength of passwords. Risk analysis\n\u000044",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 44,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•Code reviews involve one or more people examining the code to check for errors and anomalies and discussing issues with the developer. •If problems are identiﬁed, it is the developer’s responsibility to change the code to ﬁx the problems. •Code reviews complement testing. They are effective in ﬁnding bugs that arise through misunderstandings and bugs that may only arise when unusual sequences of code are executed.•Many software companies insist that all code has to go through a process of code review before it is integrated into the product codebase.Code reviews\n\u000045",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 45,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingFigure 9.9 Code reviews\n\u000046Review preparationProgrammerReviewerProgrammerDiscussionSetupreviewPreparecodeDistributecode/testsWrite reviewreportCode checkingPrepare to-do listMake codechangesReviewFollow-upFigure 9.9 Code reviewsReviewerCheckcodeProgrammer",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 46,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingSetup review The programmer contacts a reviewer and arranges a review date.Prepare code The programmer collects the code and tests for review and annotates them with information for the reviewer about the intended purpose of the code and tests.Distribute code/tests The programmer sends code and tests to the reviewer.Check code The reviewer systematically checks the code and tests against their understanding of what they are supposed to do.Write review report The reviewer annotates the code and tests with a report of the issues to be discussed at the review meeting.Table 9.12 Code review activities (1)\n\u000047",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 47,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingDiscussion The reviewer and programmer discuss the issues and agree on the actions to resolve these.Make to-do list The programmer documents the outcome of the review as a to-do list and shares this with the reviewer.Make code changes The programmer modiﬁes their code and tests to address the issues raised in the review.Table 9.12 Code review activities (2)\n\u000048",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 48,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:TestingAre meaningful variable and function names used? (General) Meaningful names make a program easier to read and understand.Have all data errors been considered and tests written for them? (General) It is easy to write tests for the most common cases but it is equally important to check that the program won’t fail when presented with incorrect data.Are all exceptions explicitly handled? (General) Unhandled exceptions may cause a system to crash.Are default function parameters used? (Python) Python allows default values to be set for function parameters when the function is deﬁned. This often leads to errors when programmers forget about or misuse them.  Are types used consistently? (Python) Python does not have compile-time type checking so it it is possible to assign values of different types to the same variable. This is best avoided but, if used, it should be justiﬁed.Is the indentation level correct? (Python) Python uses indentation rather than explicit brackets after conditional statements to indicate the code to be executed if the condition is true or false. If the code is not properly indented in nested conditionals this may mean that incorrect code is executed.Table 9.13 Part of a checklist for a Python code review \n\u000049",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 49,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•The aim of program testing is to ﬁnd bugs and to show that a program does what its developers expect it to do. •Four types of testing that are relevant to software products are functional testing, user testing, load and performance testing and security testing.•Unit testing involves testing program units such as functions or class methods that have a single responsibility. Feature testing focuses on testing individual system features. System testing tests the system as a whole to check for unwanted interactions between features and between the system and its environment.•Identifying equivalence partitions, in which all inputs have the same characteristics, and choosing test inputs at the boundaries of these partitions, is an effective way of ﬁnding bugs in a program.•User stories may be used as a basis for deriving feature tests.•Test automation is based on the idea that tests should be executable. You develop a set of executable tests and run these each time you make a change to a system.Key points 1\n\u000050",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 50,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Testing•The structure of an automated unit test should be arrange-action-assert. You set up the test parameters, call the function or method being tested, and make an assertion of what should be true after the action has been completed.•Test-driven development is an approach to development where executable tests are written before the code. Code is then developed to pass the tests.•A disadvantage of test-driven development is that programmers focus on the detail of passing tests rather than considering the broader structure of their code and algorithms used.•Security testing may be risk driven where a list of security risks is used to identify tests that may identify system vulnerabilities.•Code reviews are an effective supplement to testing. They involve people checking the code to comment on the code quality and to look for bugs.Key points 2\n\u000051",
    "metadata": {
      "deck_id": 18,
      "slide_id": 35,
      "page_number": 51,
      "title": "9. Testing.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/9. Testing.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018Security and Privacy",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 1,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Software security should always  be a high priority for product developers and their users. •If you don’t prioritize security, you and your customers will inevitably suffer losses from malicious attacks. •In the worst case, these attacks could can put product providers out of business. •If their product is unavailable or if customer data is compromised, customers are liable to cancel their subscriptions. •Even if they can recover from the attacks, this will take time and effort that would have been better spent working on their software.Software security\n\u00002",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 2,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.1 Types of security threat\n\u00003PROGRAMDATAAvailabilitythreatsIntegritythreats\nConfidentialitythreatsAn attacker attemptsto damage the systemor its data.An attacker attemptsto deny access to the systemfor legitimate users\nAn attacker tries to gainaccess to private informationheld by the systemExample: Data theftExample: Distributed denialof service attackExample: VirusExample: Ransomware Figure 7.1 Types of security threat\nSOFTWARE PRODUCT",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 3,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.2 System infrastructure stack\n\u00004Software infrastructure Application Operational environmentFrameworks and application librariesFigure 7.2 System infrastructure stack\nNetworkOperating systemDatabaseSystem librariesBrowsers and messaging",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 4,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyAuthentication and authorization You should have authentication and authorization standards and procedures that ensure that all users have strong authentication and that they have properly access permissions properly. This minimizes the risk of unauthorized users accessing system resources.System infrastructure management Infrastructure software should be properly conﬁgured and security updates that patch vulnerabilities should be applied as soon as they become available. Attack monitoring The system should be regularly checked for possible unauthorized access. If attacks are detected, it may be possible to put resistance strategies in place that minimize the effects of the attack.Backup Backup policies should be implemented to ensure that you keep undamaged copies of program and data ﬁles. These can then be restored after an attack.Table 7.1 Security management\n\u00005",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 5,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Operational security focuses on helping users to maintain security. User attacks try to trick users into disclosing their credentials or accessing a website that includes malware such as a key-logging system. •Operational security procedures and practices•Auto-logout, which addresses the common problem of users forgetting to logout from a computer used in a shared space. •User command logging, which makes it possible to discover actions taken by users that have deliberately or accidentally damaged some system resources. •Multi-factor authentication, which reduces the chances of an intruder gaining access to the system using stolen credentials.Operational security\n\u00006",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 6,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Injection attacks are a type of attack where a malicious user uses a valid input ﬁeld to input malicious code or database commands. •These malicious instructions are then executed, causing some damage to the system. Code can be injected that leaks system data to the attackers. •Common types of injection attack include buffer overﬂow attacks and SQL poisoning attacks.Injection attacks\n\u00007",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 7,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•SQL poisoning attacks are attacks on software products that use an SQL database. •They take advantage of a situation where a user input is used as part of an SQL command. •A malicious user uses a form input ﬁeld to input a fragment of SQL that allows access to the database.•The form ﬁeld is added to the SQL query, which is executed and returns the information to the attacker. SQL poisoning attacks\n\u00008",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 8,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Cross-site scripting attacks are another form of injection attack. •An attacker adds malicious Javascript code to the web page that is returned from a server to a client and this script is executed when the page is displayed in the user’s browser. •The malicious script may steal customer information or direct them to another website. •This may try to capture personal data or display advertisements. •Cookies may be stolen, which makes a session hijacking attack possible.•As with other types of injection attack, cross-site scripting attacks may be avoided by input validation.Cross-site scripting attacks\n\u00009",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 9,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.3 Cross-site scripting attack\n\u000010AttackerBrowserWebsite1.Introduce malicious code\nVictimProduct website3.Malware scriptsends session cookieto attackerMalicious code added to valid dataValid request for datafrom website2.Data delivered and malwarescript installed in victim’s browserFigure 7.3 Cross-site scripting attack\nBrowser",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 10,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•When a user authenticates themselves with a web application, a session is created. •A session is a time period during which the user’s authentication is valid. They don’t have to re-authenticate for each interaction with the system. •The authentication process involves placing a session cookie on the user’s device•Session hijacking is a type of attack where an attacker gets hold of a session cookie and uses this to impersonate a legitimate user. •There are several ways that an attacker can ﬁnd out the session cookie value including cross-site scripting attacks and trafﬁc monitoring. •In a cross-site scripting attack, the installed malware sends session cookies to the attackers. •Trafﬁc monitoring involves attackers capturing the trafﬁc between the client and server. The session cookie can then be identiﬁed by analysing the data exchanged. Session hijacking attacks\n\u000011",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 11,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyTrafﬁc encryption Always encrypt the network trafﬁc between clients and your server. This means setting up sessions using https rather than http. If trafﬁc is encrypted it is harder to monitor to ﬁnd session cookies.Multi-factor authentication Always use multi-factor authentication and require conﬁrmation of new actions that may be damaging. For example, before a new payee request is accepted, you could ask the user to conﬁrm their identity by inputting a code sent to their phone.  You could also ask for password characters to be input before every potentially damaging action, such as transferring funds.Short timeouts Use relatively short timeouts on sessions. If there has been no activity in a session for a few minutes, the session should be ended and future requests directed to an authentication page. This reduces the likelihood that an attacker can access an account if a legitimate user forgets to log off when they have ﬁnished their transactions.Table 7.2 Actions to reduce the likelihood of hacking\n\u000012",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 12,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Denial of service attacks are attacks on a software system that are intended to make that system unavailable for normal use. •Distributed denial of service attacks (DDOS) are the most common type of denial of service attacks. •These involve distributed computers, that have usually been hijacked as part of a botnet, sending hundreds of thousands of requests for service to a web application.  There are so many service requests that legitimate users are denied access.•Other types of denial of service attacks target application users. •User lockout attacks take advantage of a common authentication policy that locks out a user after a number of failed authentication attempts. Their aim is to lock users out rather than gain access and so deny the service to these users.•Users often use their email address as their login name so if an attacker has access to a database of email addresses, he or she can try to login using these addresses.•If you don’t lock accounts after failed validation, then attackers can use brute-force attacks on your system. If you do, you may deny access to legitimate users. Denial of service attacks\n\u000013",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 13,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Brute force attacks are attacks on a web application where the attacker has some information, such as a valid login name, but does not have the password for the site. •The attacker creates different passwords and tries to login with each of these. If the login fails, they then try again with a different password.•Attackers may use a string generator that generates every possible combination of letters and numbers and use these as passwords. •To speed up the process of password discovery, attackers take advantage of the fact that many users choose easy-to-remember passwords. They start by trying passwords from the published lists of the most common passwords. •Brute force attacks rely on users setting weak passwords, so you can circumvent them by insisting that users set long passwords that are not in a dictionary or are common words. Brute force attacks\n\u000014",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 14,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Authentication is the process of ensuring that a user of your system is who they claim to be. •You need authentication in all software products that maintain user information, so that only the providers of that information can access and change it. •You also use authentication to learn about your users so that you can personalize their experience of using your product.Authentication\n\u000015",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 15,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.4 Authentication approaches\n\u000016Mobile deviceAuthentication approachExampleFigure 7.4 Authentication approaches\nAuthenticating userFingerprintPasswordAttributePossessionKnowledge",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 16,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Knowledge-based authentication•The user provides secret, personal information when they register  with the system. Each time they log on, the system asks them for this information.•Possession-based authentication •This relies on the user having a physical device (such as a mobile phone) that can generate or display information that is known to the authenticating system. The user inputs this information to conﬁrm that they possess the authenticating device.•Attribute-based authentication is based on a unique biometric attribute of the user, such as a ﬁngerprint, which is registered with the system.•Multi-factor authentication combines these approaches and requires users to use more than one authentication method.Authentication methods\n\u000017",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 17,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyInsecure passwords Users choose passwords that are easy to remember. However, it is also easy for attackers to guess or generate these passwords, using either a dictionary or a brute force attack.Phishing attacks Users click on an email link that points to a fake site that tries to collect their login and password details.Password reuse Users use the same password for several sites. If there is a security breach at one of these sites, attackers then have passwords that they can try on other sites.Forgotten passwords Users regularly forget their passwords so that you need to set up a password recovery mechanism to allow these to be reset. This can be a vulnerability if users’ credentials have been stolen and attackers use it to reset their passwords.Table 7.3 Weaknesses of password-password-based authentication\n\u000018",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 18,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Federated identity is an approach to authentication where you use an external authentication service.•‘Login with Google’ and ‘Login with Facebook’ are widely used examples of authentication using federated identity.•The advantage of federated identity for a user is that they have a single set of credentials that are stored by a trusted identity service. •Instead of logging into a service directly, a user provides their credentials to a known service who conﬁrms their identity to the authenticating service. •They don’t have to keep track of different user ids and passwords. Because their credentials are stored in fewer places, the chances of a security breach where these are revealed is reduced.Federated identity\n\u000019",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 19,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.5 Federated identity\n\u000020ServiceRequest authenticationDivert requestRequest credentialsProvide credentialsReturn authentication tokenAuthentication responseFigure 7.5 Federated identityUserTrusted authenticator",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 20,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Authentication involves a user proving their identity to a software system. •Authorization is a complementary process in which that identity is used to control access to software system resources. •For example, if you use a shared folder on Dropbox, the folder’s owner may authorize you to read the contents of that folder, but not to add new ﬁles or overwrite ﬁles in the folder.•When a business wants to deﬁne the type of access that users get to resources, this is based on an access control policy. •This policy is a set of rules that deﬁne what information (data and programs) is controlled, who has access to that information and the type of access that is allowedAuthorization\n\u000021",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 21,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Explicit access control policies are important for both legal and technical reasons. •Data protection rules limit the access the personal data and this must be reﬂected in the deﬁned access control policy. If this policy is incomplete or does not conform to the data protection rules, then there may be subsequent legal action in the event of a data breach. •Technically, an access control policy can be a starting point for setting up the access control scheme for a system. •For example, if the access control policy deﬁnes the access rights of students, then when new students are registered, they all get these rights by default.Access control policies\n\u000022",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 22,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Access control lists (ACLs) are used in most ﬁle and database systems to implement access control policies. •Access control lists are tables that link users with resources and specify what those users are permitted to do. •For example, for this book I would like to be able to set up an access control list to a book ﬁle that allows reviewers to read that ﬁle and annotate it with comments. However, they are not allowed to edit the text or to delete the ﬁle.•If access control lists are based on individual permissions, then these can become very large. However, you can dramatically cut their size by allocating users to groups and then assigning permissions to the group Access control lists\n\u000023",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 23,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.8 Access control lists\n\u000024DABCDResourceAccess\n...Figure 7.8 Access control listsUserPermissionsAllStaffSysadminReadCreate, EditDeleteUserPermissionsAllSysadminExecuteCreate, DeleteUserAdminTeaching staffStudentCreate, Read, EditPermissionsRead, Edit Readif department = dept_idif student = student_id",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 24,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Encryption is the process of making a document unreadable by applying an algorithmic transformation to it. •A secret key is used by the encryption algorithm as the basis of this transformation. You can decode the encrypted text by applying the reverse transformation. •Modern encryption techniques are such that you can encrypt data so that it is practically uncrackable using currently available technology. •However, history has demonstrated that apparently strong encryption may be crackable when new technology becomes available.•If commercial quantum systems become available, we will have to use a completely different approach to encryption on the Internet.Encryption\n\u000025",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 25,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.9 Encryption and decryption\n\u000026SecretkeyDecryptFigure 7.9 Encryption and decryption\nPlain textEncryptedtextEncryptPlain textSecretkey",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 26,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•In a symmetric encryption scheme, the same encryption key is used for encoding and decoding the information that is to be kept secret. •If Alice and Bob wish to exchange a secret message, both must have a copy of the encryption key. Alice encrypts the message with this key. When Bob receives the message, he decodes it using the same key to read its contents.•The fundamental problem with a symmetric encryption scheme is securely sharing the encryption key. •If Alice simply sends the key to Bob, an attacker may intercept the message and gain access to the key. The attacker can then decode all future secret communications.Symmetric encryption\n\u000027",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 27,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.10 Symmetric encryption\n\u000028Encryption key\nSecret messageEncryption keyFigure 7.10 Symmetric encryptionAliceBob\nEncrypted textSecret messagea7Dr6yYt9F...a7Dr6yYt9F...encryptdecrypt",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 28,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Asymmetric encryption, does not require secret keys to be shared. •An asymmetric encryption scheme uses different keys for encrypting and decrypting messages. •Each user has a public and a private key. Messages may be encrypted using either key but can only be decrypted using the other key.•Public keys may be published and shared by the key owner. Anyone can access and use a published public key. •However, messages can only be decrypted by the user’s private key so is only readable by the intended recipientAsymmetric encryption\n\u000029",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 29,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.11 Asymmetric encryption\n\u000030Bob’s public key\nSecret messageBob’s private keyFigure 7.11 Asymmetric encryptionAliceBob\nEncrypted textSecret messagedr5ts3TR9dtx4ztmRsYY...hTr34BbfsDy9r3g5HHt76...encryptdecrypt",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 30,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Asymmetric encryption can also be used to authenticate the sender of a message by encrypting it with a private key and decrypting it with the corresponding public key. •Say Alice wants to send a message to Bob and she has a copy of his public key. •However, she is not sure whether or not the public key that she has for Bob is correct and she is concerned that the message may be sent to the wrong person.• Private/public key encryption can be used to verify Bob’s identity. •Bob uses his private key to encrypt a message and sends this to Alice. If it can be decrypted using Bob’s public key, then Alice has the correct key.Encryption and authentication\n\u000031",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 31,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.12 Encryption for authentication\n\u000032Bob’s private key\nI am reallyBobBob’s public keyFigure 7.12 Encryption for authenticationAliceBob\nEncrypted textdr5ts3TR9dtx4ztmRsYY...hTr34BbfsDy9r3g5HHt76...I am reallyBobencryptdecrypt",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 32,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•The https protocol is a standard protocol for securely exchanging texts on the web. It is the standard http protocol plus an encryption layer called TLS (Transport Layer Security). This encryption layer is used for 2 things:• to verify the identity of the web server;•to encrypt communications so that they cannot be read by an attacker who intercepts the messages between the client and the server•TLS encryption depends on a digital certiﬁcate that is sent from the web server to the client. •Digital certiﬁcates are issued by a certiﬁcate authority (CA), which is a trusted identity veriﬁcation service. •The CA encrypts the information in the certiﬁcate using their private key to create a unique signature. This signature is included in the certiﬁcate along with the public key of the CA. To check that the certiﬁcate is valid, you can decrypt the signature using the CA’s public key.TLS and digital certiﬁcates\n\u000033",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 33,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacySubject information Information about the company or individual whose web site is being visited. Applicants apply for a digital certiﬁcate from a certiﬁcate authority who checks that the applicant is a valid organization.Certiﬁcate authority information Information about the certiﬁcate authority (CA) who has issued the certiﬁcate.  Certiﬁcate information Information about the certiﬁcate itself, including a unique serial number and a validity period, deﬁned by start and end dates. Digital signature The combination of all of the above data uniquely identiﬁes the digital certiﬁcate. The signature data is encrypted with the CA’s private key to conﬁrm that the data is correct. The algorithm used to generate the digital signature is also speciﬁed.Public key information The public key of the CA is included along with the key size and the encryption algorithm used. The public key may be used to decrypt the digital signature.Table 7.5 Digital certiﬁcates\n\u000034",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 34,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.13 Using symmetric and asymmetric encryption in TLS \n\u000035CLIENTSERVEREncryption methods supportedEncryption method to be usedProve your identity?HelloGenerate RSEncrypt RS\nComputekeyGet certificateRC is a large random numberCheckCheck certificate issuer and validity and digital signature on certificateGenerate RCRS is a large random numberDigital certificate +  encrypted RS\nEncryptRCDecrypt RS and encrypt RC using public key from digital certificateEncrypted RCDecryptRCDecrypt RC using private keyCompute the symmetric key using RS and RCComputekeyCompute the symmetric key using RS and RCData encrypted using symmetric keyFigure 7.13 Using symmetric and asymmetric encryption in TLS\nEncrypt RS usingprivate key\nDecryptRSHelloVerify\nExchangedataEndsessionEndsessionExchangedata",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 35,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•The digital certiﬁcate that the server sends to the client includes the server’s public key. The server also generates a long random number, encrypts it using its private key and sends this to the client. •The client can then decrypt this using the server’s public key and, in turn, generates its own long random number. It encrypts this number using the server’s public key and sends it to the server, which decrypts the message using its private key. Both client and server then have two long random numbers. •The agreed encryption method includes a way of generating an encryption key from these numbers. The client and server independently compute the key that will be used to encrypt subsequent messages using a symmetric approach. •All client-server trafﬁc is encrypted and decrypted using that computed key. There is no need to exchange the key itself.TLS explained\n\u000036",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 36,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•As a product provider you inevitably store information about your users and, for cloud-based products, user data. •Encryption can be used to reduce the damage that may occur from data theft. If information is encrypted, it is impossible, or very expensive, for thieves to access and use the unencrypted data.•Data in transit.   When transferring the data over the Internet, you should always use the https rather than the http protocol to ensure encryption.•Data at rest.  If data is not being used, then the ﬁles where the data is stored should be encrypted so that theft of these ﬁles will not lead to disclosure of conﬁdential information. •Data in use The data is being actively processed. Encrypting and decrypting the data slows down the system response time. Implementing a general search mechanism with encrypted data is impossible,Data encryption\n\u000037",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 37,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.14 Encryption levels\n\u000038Figure 7.14 Encryption levels\nThe operating system encrypts disks when they are unmounted and decrypts these disks when they are remounted.The operating system encrypts individual files when they are closed and decrypts them when they are reopened.The DMBS may encrypt the entire database when it is closed, with the database decrypted when it is reopened. Alternatively individal tables or columns may be encrypted/decrypted.The application decides what data should be encrypted and decrypts that data immediately before it is used.ApplicationDatabaseFilesMedia",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 38,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Key management is the process of ensuring that encryption keys are securely generated, stored and accessed by authorized users. •Businesses may have to manage tens of thousands of encryption keys so it is impractical to do key management manually and you need to use some kind of automated key management system (KMS). •Key management is important because, if you get it wrong, unauthorized users may be able to access your keys and so decrypt supposedly private data. Even worse, if you lose encryption keys, then your encrypted data may be permanently inaccessible. •A key management system (KMS) is a specialized database that is designed to securely store and manage encryption keys, digital certiﬁcates and other conﬁdential information. Key management\n\u000039",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 39,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.15 Using a KMS for encryption management\n\u000040APICallsFigure 7.15 Using a KMS for encryption management\nKeysStored encrypted dataApplicationUnencrypted dataEncryption engineKey storeKey management systemAPI",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 40,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Business may be required by accounting and other regulations to keep copies of all of their data for several years. •For example, in the UK, tax and company data has to be maintained for at least six years, with a longer retention period for some types of data. Data protection regulations may require that this data be stored securely, so the data should be encrypted. •To reduce the risks of a security breach, encryption keys should be changed regularly. This means that archival data may be encrypted with a different key from the current data in your system. •Therefore, key management systems must maintain multiple, timestamped versions of keys so that system backups and archives can be decrypted if required. •Long-term key storage\n\u000041",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 41,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•Privacy is a social concept that relates to the collection, dissemination and appropriate use of personal information held by a third-party such as a company or a hospital. •The importance of privacy has changed over time and individuals have their own views on what degree of privacy is important. •Culture and age also affect peoples’ views on what privacy means.•Younger people were early adopters of the ﬁrst social networks and many of them seem to be less inhibited about sharing personal information on these platforms than older people.•In some countries, the level of income earned by an individual is seen as a private matter;  in others, all tax returns are openly published.  Privacy\n\u000042",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 42,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•If you are offering a product directly to consumers and you fail to conform to privacy regulations, then you may be subject to legal action by product buyers or by a data regulator. If your conformance is weaker than the protection offered by data protection regulations in some countries, you won’t be able to sell your product in these countries.•If your product is a business product, business customers require privacy safeguards so that they are not put at risk of privacy violations and legal action by users.•If personal information is leaked or misused, even if this is not seen as a violation of privacy regulations, this can lead to serious reputational damage. Customers may stop using your product because of thisBusiness reasons for privacy\n\u000043",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 43,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•In many countries, the right to individual privacy is protected by data protection laws. •These laws limit the collection, dissemination and use of personal data to the purposes for which it was collected. •For example, a travel insurance company may collect health information so that they can assess their level of risk. This is legal and permissible. •However, it would not be legal for those companies to use this information to target online advertising of health products, unless their users had given speciﬁc permission for this.Data protection laws\n\u000044",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 44,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyFigure 7.16 Data protection laws\n\u000045Data protectionlawsResponsibilities ofthe data controllerFigure 7.16 Data protection lawsRights of the data subjectData storageData useSecuritySubject accessData accessError correctionData deletionConsent",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 45,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacyAwareness and control Users of your product must be made aware of what data is collected when they are using your product, and must have control over the personal information that you collect from them.Purpose You must tell users why data is being collected and you must not use that data for other purposes.Consent You must always have the consent of a user before you disclose their data to other people.Data lifetime You must not keep data for longer than you need to. If a user deletes their account, you must delete the personal data associated with that account.Table 7.6 Data protection principles (1)\n\u000046",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 46,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and PrivacySecure storage You must maintain data securely so that it cannot be tampered with or disclosed to unauthorized people.Discovery and error correction You must allow users to ﬁnd out what personal data that you store. You must provide a way for users to correct errors in their personal data.Location You must not store data in countries where weaker data protection laws apply unless there is an explicit agreement that the stronger data protection rules will be upheld.Data protection principles (2)\n\u000047",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 47,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•You should to establish a privacy policy that deﬁnes how personal and sensitive information about users is collected, stored and managed.  •Software products use data in different ways, so your privacy policy has to deﬁne the personal data that you will collect and how you will use that data. •Product users should be able to review your privacy policy and change their preferences regarding the information that you store. •Your privacy policy is a legal document and it should be auditable to check that it is consistent with the data protection laws in countries where your software is sold.•Privacy policies should not be expressed to users in a long ‘terms and conditions’ document that, in practice, nobody reads. •The GDPR now require software companies to include a summary of their privacy policy, written in plain language rather than legal jargon, on their website. •Privacy policy\n\u000048",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 48,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy• Security is a technical concept that relates to a software system’s ability to protect itself from malicious attacks that may threaten its availability, the integrity of the system and/or its data, and the theft of conﬁdential information.•Common types of attack on software products include injection attacks, cross-site scripting attacks, session hijacking attacks, denial of service attacks and brute force attacks.•Authentication may be based on something a user knows, something a user has, or some physical attribute of the user.•Federated authentication involves devolving responsibility for authentication to a third-party such as Facebook or Google, or to a business’s authentication service.•Authorization involves controlling access to system resources based on the user’s authenticated identity. Access control lists are the most commonly-used mechanism to implement authorization.•Symmetric encryption involves encrypting and decrypting information with the same secret key. Asymmetric encryption uses a key pair – a private key and a public key. Information encrypted using the public key can only be decrypted using the private key.Key points 1\n\u000049",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 49,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Security and Privacy•A major issue in symmetric encryption is key exchange. The TLS protocol, which is used to secure web trafﬁc, gets around this problem by using asymmetric encryption for transferring information used to generate a shared key.•If your product stores sensitive user data, you should encrypt that data when it is not in use.•A key management system (KMS) stores encryption keys. Using a KMS is essential because a business may have to manage thousands or even millions of keys and may have to decrypt historic data that was encrypted using an obsolete encryption key. •Privacy is a social concept that relates to how people feel about the release of their personal information to others. Different countries and cultures have different ideas on what information should and should not be private.•Data protection laws have been made in many countries to protect individual privacy. They require companies who manage user data to store it securely, to ensure that it is not used or sold without the permission of users, and to allow users to view and correct personal data held by the system.Key points 2\n\u000050",
    "metadata": {
      "deck_id": 18,
      "slide_id": 36,
      "page_number": 50,
      "title": "7. Security and Privacy.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/7. Security and Privacy.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018Agile Software Engineering",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 1,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Software products must be brought to market quickly so rapid software development and delivery is essential.•Virtually all software products are now developed using an agile approach.•Agile software engineering focuses on delivering functionality quickly, responding to changing product speciﬁcations and minimizing development overheads. •A large number of ‘agile methods’ have been developed. •There is no ‘best’ agile method or technique.•It depends on who is using the technique, the development team and the type of product being developedAgile software engineering\n\u00002",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 2,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Plan-driven development evolved to support the engineering of large, long-lifetime systems (such as aircraft control systems) where teams may be geographically dispersed and work on the software for several years.•This approach is based on controlled and rigorous software development processes that include detailed project planning, requirements speciﬁcation and analysis and system modelling.•However, plan-driven development involves signiﬁcant overheads and documentation and it does not support the rapid development and delivery of software.•Agile methods were developed in the 1990s to address this problem. •These methods focus on the software rather than its documentation, develop software in a series of increments and aim to reduce process bureaucracy as much as possible.Agile methods\n\u00003",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 3,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringWe are uncovering better ways of developing software by doing it and helping others to do it. Through this work, we have come to value:- individuals and interactions over processes and tools;- working software over comprehensive documentation;- customer collaboration over contract negotiation;- responding to change over following a plan.While there is value on the items on the right, we value the items on the left more.Table 2.1 The agile manifesto\n\u00004",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 4,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•All agile methods are based around incremental development and delivery. •Product development focuses on the software features, where a feature does something for the software user.•With incremental development, you start by prioritizing the features so that the most important features are implemented ﬁrst. •You only deﬁne the details of the feature being implemented in an increment. •That feature is then implemented and delivered. •Users or surrogate users can try it out and provide feedback to the development team. You then go on to deﬁne and implement the next feature of the system.Incremental development\n\u00005",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 5,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.1 Incremental development\n\u00006Figure 2.1 Incremental developmentProduct feature listIf all features are complete, deliver system releaseChoose features to be included in incrementRefine feature descriptionsDeliver system incrementIntegrate feature into systemImplement andtest feature",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 6,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringChoose features to be included in an increment Using the list of features in the planned product, select those features that can be implemented in the next product increment.Reﬁne feature descriptions Add detail to the feature descriptions so that the team have a common understanding of each feature and there is sufﬁcient detail to begin implementation.Implement and test Implement the feature and develop automated tests for that feature that show that its behaviour is consistent with its description.  Integrate feature and test Integrate the developed feature with the existing system and test it to check that it works in conjunction with other features.Deliver system increment Deliver the system increment to the customer or product manager for checking and comments. If enough features have been implemented, release a version of the system for customer use.Table 2.2 Incremental development activities\n\u00007",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 7,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringInvolve the customer Involve customers closely with the software development team. Their role is to provide and prioritize new system requirements and to evaluate each increment of the system. Embrace change Expect the features of the product and the details of these features to change as the development team and the product manager learn more about it. Adapt the software to cope with changes as they are made.Develop and deliver incrementally Always develop software products in increments. Test and evaluate each increment as it is developed and feed back required changes to the development team.   Table 2.3 Agile development principles\n\u00008",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 8,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringMaintain simplicity Focus on simplicity in both the software being developed and in the development process. Wherever possible, do what you can to eliminate complexity from the system.Focus on people, not things Trust the development team and do not expect everyone to always do the development process in the same way. Team members should be left to develop their own ways of working without being limited by prescriptive software processes.Table 2.3 Agile development principles\n\u00009",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 9,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•The most inﬂuential work that has changed software development culture was the development of Extreme Programming (XP). •The name was coined by Kent Beck in 1998 because the approach was developed by pushing recognized good practice, such as iterative development, to ‘extreme’ levels.•Extreme programming focused on 12 new development techniques that were geared to rapid, incremental software development, change and delivery.•Some of these techniques are now widely used; others have been less popular.•The most widely used XP techniques (highlighted in red on the following slide) are explained elsewhere in the book.Extreme programming\n\u000010",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 10,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.2 Extreme programming practices\n\u000011Test-firstdevelopmentRefactoring\nPair programmingSimpledesignOn-sitecustomerSustainablepaceContinuousintegrationSmallreleasesIncrementalplanningCollectiveownershipExtremeprogrammingFigure 2.2 Extreme programming practices",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 11,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringIncremental planning/user stories There is no ‘grand plan’ for the system. Instead, what needs to be implemented (the requirements) in each increment are established in discussions with a customer representative. The requirements are written as user stories. The stories to be included in a release are determined by the time available and their relative priority. Small releases The minimal useful set of functionality that provides business value is developed ﬁrst. Releases of the system are frequent and incrementally add functionality to the previous release.Test-driven development  Instead of writing code then tests for that code, developers write the tests ﬁrst. This helps clarify what the code should actually do and that there is always a ‘tested’ version of the code available. An automated unit test framework is used to run the tests after every change. New code should not ‘break’ code that has already been implemented.Table 2.4 Widely adopted XP practices\n\u000012",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 12,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringContinuous integration As soon as the work on a task is complete, it is integrated into the whole system and a new version of the system is created. All unit tests from all developers are run automatically and must be successful before the new version of the system is accepted.Refactoring Refactoring means improving the structure, readability, efﬁciency and security of a program. All developers are expected to refactor the code as soon as potential code improvements are found. This keeps the code simple and maintainable.Table 2.4 Widely adopted XP practices\n\u000013",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 13,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Software company managers need information that will help them understand how much it costs to develop a software product, how long it will take and when the product can be brought to market.•Plan-driven development provides this information through long-term development plans that identify deliverables - items the team will deliver and when these will be delivered.•Plans always change so anything apart from short-term plans are unreliable.•Scrum is an agile method that provides a framework for agile project organization and planning. It does not mandate any speciﬁc technical practices. Scrum\n\u000014",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 14,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringProduct The software product that is being developed by the Scrum team.Product owner A team member who is responsible for identifying product features and attributes. They review work done and help to test the product.Product backlog A to-do list of items such as bugs, features and product improvements that the Scrum team have not yet completed.Development team A small self-organising team of ﬁve to eight people who are responsible for developing the product.Sprint  A short period, typically two to four weeks, when a product increment is developed.Table 2.5 Scrum terminology\n\u000015",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 15,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringScrum A daily team meeting where progress is reviewed and work to be done that day as discussed and agreed.ScrumMaster A team coach who guides the team in the effective use of Scrum.Potentially shippable product increment The output of a sprint which should be of high enough quality to be deployed for customer use.Velocity An estimate of how much work a team can do in a single sprint.Table 2.5 Scrum terminology\n\u000016",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 16,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•The Product Owner is responsible for ensuring that the development team are always focused on the product they are building rather than diverted into technically interesting but less relevant work. •In product development, the product manager should normally take on the Product Owner role.   •The ScrumMaster is a Scrum expert whose job is to guide the team in the effective use of the Scrum method. The developers of Scrum emphasize that the ScrumMaster is not a conventional project manager but is a coach for the team. They have authority within the team on how Scrum is used. •In many companies that use Scrum, the ScrumMaster also has some project management responsibilities.Key roles in Scrum\n\u000017",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 17,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•In Scrum, software is developed in sprints, which are ﬁxed-length periods (2 - 4 weeks) in which software features are developed and delivered.•During a sprint, the team has daily meetings (Scrums) to review progress and to update the list of work items that are incomplete.•Sprints should produce a ‘shippable product increment’. This means that the developed software should be complete and ready to deploy.Scrum and sprints\n\u000018",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 18,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.3 Scrum cycles\n\u000019ScrumDevelopsoftwareTestsoftwareSelect itemsto implementPlansprintSprintReviewsprintReview product backlogFigure 2.3. Scrum cycles\nProductbacklogShippableproduct incrementSprintbacklogStart",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 19,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.4 The top ﬁve beneﬁts of using Scrum\n\u000020Product\nProgressPeopleUnstable requirements do not hold up progress.The product is broken down into a set of understandable chunks that stakeholders can relate to.\nCustomers see on-time delivery of increments and gain feedback on how the product works. Team communication is improved because everyone can see  everything.ScrumbenefitsFigure 2.4 The top-five benefits of using Scrum\nTrust between customers and developers is established and a positive culture is created.",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 20,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Product backlog This is a to-do list of items to be implemented that is reviewed and updated before each sprint.•Timeboxed sprints Fixed-time (2-4 week) periods in which items from the product backlog are implemented,•Self-organizing teams Self-organizing teams make their own decisions and work by discussing issues and making decisions by consensus. Key Scrum practices\n\u000021",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 21,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•The product backlog is a list of what needs to be done to complete the development of the product. •The items on this list are called product backlog items (PBIs). •The product backlog may include a variety of different items such as product features to be implemented, user requests, essential development activities and desirable engineering improvements.  •The product backlog should always be prioritized so that the items that be implemented ﬁrst are at the top of the list.  Product backlogs\n\u000022",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 22,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering1.  As a teacher, I want to be able to conﬁgure the group of tools that are available to individual classes. (feature)2.  As a parent, I want to be able to view my childrens’ work and the assessments made by their teachers. (feature)3.  As a teacher of young children, I want a pictorial interface for children with limited reading ability. (user request)4. Establish criteria for the assessment of open source software that might be used as a basis for parts of this system. (development activity)5.  Refactor user interface code to improve understandability and performance. (engineering improvement)6.  Implement encryption for all personal user data. (engineering improvement)Table 2.6 Examples of product backlog items\n\u000023",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 23,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringReady for consideration These are high-level ideas and feature descriptions that will be considered for inclusion in the product. They are tentative so may radically change or may not be included in the ﬁnal product.Ready for reﬁnement The team has agreed that this is an important item that should be implemented as part of the current development. There is a reasonably clear deﬁnition of what is required. However, work is needed to understand and reﬁne the item.Ready for implementation The PBI has enough detail for the team to estimate the effort involved and to implement the item. Dependencies on other items have been identiﬁed.Table 2.7 Product backlog item states\n\u000024",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 24,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.5 Product backlog activities\n\u000025Figure 2.5 Product backlog activitiesPRODUCT BACKLOG\nCreationRefinementEstimationPBI 1PBI 2PBI 3PBI 5PBI 4PBI 4PBI 1.1PBI 1.2PBI 3EPBI 2EPrioritizationCreationPBI 6PBI 5REVISEDPRODUCT BACKLOG",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 25,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Reﬁnement  Existing PBIs are analysed and reﬁned to create more detailed PBIs. This may lead to the creation of new product backlog items.•Estimation The team estimate the amount of work required to implement a PBI and add this assessment to each analysed PBI.•Creation  New items are added to the backlog. These may be new features suggested by the product manager, required feature changes, engineering improvements, or process activities such as the assessment of development tools that might be used.•Prioritization The product backlog items are reordered to take new information and changed circumstances into account.•Product backlog activities\n\u000026",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 26,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Effort required•This may be expressed in person-hours or person-days i.e. the number of hours or days it would take one person to implement that PBI. This is not the same as calendar time. Several people may work on an item, which may shorten the calendar time required.  •Story points•Story points are an arbitrary estimate of the effort involved in implementing a PBI, taking into account the size of the task, its complexity, the technology that may be required and the ‘unknown’ characteristics of the work. •They were derived originally by comparing user stories, but they can be used for estimating any kind of PBI. •Story points are estimated relatively. The team agree on the story points for a baseline task and other tasks are estimated by comparison with this e.g. more/less complex, larger/smaller etc.  PBI estimation metrics\n\u000027",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 27,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Products are developed in a series of sprints, each of which delivers an increment of the product or supporting software. •Sprints are short duration activities (1-4 weeks) and take place between a deﬁned start and end date. Sprints are timeboxed, which means that development stops at the end of a sprint whether or not the work has been completed.•During a sprint, the team work on the items from the product backlog.Timeboxed sprints\n\u000028",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 28,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.6 Beneﬁts of using timeboxed sprints\n\u000029Demonstrable progress\nProblem discoveryWork planningThere is a tangible output (usually a software demonstrator) that can be delivered at the end of every sprint. \nIf errors and omissions are discovered the rework required is limited to the duration of a sprint.The team develops an understand-ing of how much work they can do in a fixed time period. Time-boxingbenefitsFigure 2.6 Benefits of using timeboxed sprints",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 29,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Sprint planning  Work items to be completed in that sprint are selected and, if necessary, reﬁned to create a sprint backlog. This should not last more than a day at the beginning of the sprint.•Sprint execution The team work to implement the sprint backlog items that have been chosen for that sprint. If it is impossible to complete all of the sprint backlog items, the sprint is not extended. The unﬁnished items are returned to the product backlog and queued for a future sprint.•Sprint reviewing The work done in the sprint is reviewed by the team and (possibly) external stakeholders. The team reﬂect on what went well and what went wrong during the sprint with a view to improving their work process.Sprint activities\n\u000030",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 30,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.7 Sprint activities\n\u000031Sprint planningSprint reviewSprint backlogFigure 2.7 Sprint activities\nScrumDevelopsoftwareIntegrateSprint executionSprint backlog",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 31,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering• Establish an agreed sprint goal•Sprint goals may be focused on software functionality, support or performance and reliability,.•Decide on the list of items from the product backlog that should be implemented•Create a sprint backlog. •This is a more detailed version of the product backlog that records the work to be done during the sprintSprint planning\n\u000032",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 32,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.8 Sprint goals\n\u000033Functional\nSupportPerformance and reliabilityImplement user roles so that a user can select their role when they login to the system\nDevelop analytics that maintain information about the time users spend using each feature of the system.Ensure that the login response time is less than 10 seconds for all users where there are up to 2000 simultaneous login connections.SprintgoalsFigure 2.8 Sprint goals",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 33,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•In a sprint plan, the team decides which items in the product backlog should be implemented during that sprint.•Key inputs are the effort estimates associated with PBIs and the team’s velocity•The output of the sprint planning process is a sprint backlog.•The sprint backlog is a breakdown of PBIs to show the what is involved in implementing the PBIs chosen for that sprint.•During a sprint, the team have daily meetings (scrums) to coordinate their work.Sprint planning\n\u000034",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 34,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringA scrum is a short, daily meeting that is usually held at the beginning of the day. During a scrum, all team members share information, describe their progress since the previous day’s scrum, problems that have arisen and plans for the coming day. This means that everyone on the team knows what is going on and, if problems arise, can re-plan short-term work to cope with them.  Scrum meetings should be short and focused. To dissuade team members from getting involved in long discussions, they are sometimes organized as ‘stand-up’ meetings where there are no chairs in the meeting room.During a scrum, the sprint backlog is reviewed. Completed items are removed from it. New items may be added to the backlog as new information emerges. The team then decide who should work on sprint backlog items that day.Table 2.8 Scrums\n\u000035",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 35,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Scrum does not suggest the technical agile activities that should be used. However, I think there are two practices that should always be used in a sprint.•Test automation As far as possible, product testing should be automated. You should develop a suite of executable tests that can be run at any time.  •Continuous integration Whenever anyone makes changes to the software components they are developing, these components should be immediately integrated with other components to create a system. This system should then be tested to check for unanticipated component interaction problems. Agile activities\n\u000036",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 36,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringReviewed The code has been reviewed by another team member who has checked that it meets agreed coding standards, is understandable, includes appropriate comments, and has been refactored if necessary.Unit tested All unit tests have been run automatically and all tests have executed  successfully.Integrated The code has been integrated with the project codebase and no integration errors have been reported.Integration tested All integration tests have been run automatically and all tests have executed successfully.Accepted Acceptance tests have been run if appropriate and the product owner or the development team have conﬁrmed that the product backlog item has been completed. Table 2.9 Code completeness checklist\n\u000037",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 37,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•At the end of each sprint, there is a review meeting, which involves the whole team. This meeting:•reviews whether or not the sprint has met its goal. •sets out any new problems and issues that have emerged during the sprint.•is a way for a team to reﬂect on how they can improve the way they work. •The product owner has the ultimate authority to decide whether or not the goal of the print has been achieved. They should conﬁrm that the implementation of the selected product backlog items is complete. •The sprint review should include a process review, in which the team reﬂects on its own way of working and how Scrum has been used.  •The aim is to identify ways to improve and to discuss how to use Scrum more productively. Sprint reviews\n\u000038",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 38,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.9 Self-organizing teams\n\u000039Self-organizingteamFigure 2.9 Self-organizing teamscoordinates the work of the team members by discussing tasks andreaching a consensus onwho should do what.limits the involvement of engineers in external interactions with management and customers.makes its own decisions on schedule and deliverables.",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 39,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•The ideal Scrum team size is between 5 and 8 people. •Teams have to tackle diverse tasks and so usually require people with different skills, such as networking, user experience, database design and so on. •They usually involve people with different levels of experience.•A team of 5-8 people is large enough to be diverse yet small enough to communicate informally and effectively and to agree on the priorities of the team.•The advantage of a self-organizing team is that it can be a cohesive team that can adapt to change. •Because the team rather than individuals take responsibility for the work, they can cope with people leaving and joining the team. •Good team communication means that team members inevitably learn something about each other’s areasTeam size and composition\n\u000040",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 40,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•The developers of Scrum assumed that teams would be co-located. They would work in the same room and could communicate informally. •Daily scrums mean that the team members know what’s been done and what others are doing.  •However, the use of daily scrums as a coordination mechanism is based on two assumptions that are not always correct:•Scrum assumes that the team will be made up of full-time workers who share a workspace. In reality, team members may be part-time and may work in different places. For a student project team, the team members may take different classes at different times.•Scrum assumes that all team members can attend a morning meeting to coordinate the work for the day. However, some team members may work ﬂexible hours (e.g. because of childcare responsibilities) or may work on several projects at the same time.Team coordination\n\u000041",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 41,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•External interactions are interactions that team members have with people outside of the team. •In Scrum, the idea is that developers should focus on development and only the ScrumMaster and Product Owner should be involved in external interactions.•The intention is that the team should be able to work on software development without external interference or distractions.External interactions\n\u000042",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 42,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.10 Managing external interactions\n\u000043External interactions\nScrumMasterProduct ownerFigure 2.10 Managing external interactions\nProduct-focusedexternal interactionsTeam-focusedexternal interactions",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 43,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•In all but the smallest product development companies, there is a need for development teams to report on progress to company management.• A self-organizing team has to appoint someone to take on these responsibilities. •Because of the need to maintain continuity of communication with people outside of the group, rotating these activities around team members is not a viable approach.•The developers of Scrum did not envisage that the ScrumMaster should also have project management responsibilities. •In many companies, however, the ScrumMaster has to take on project management responsibilities.•They know the work going on and are in the best position to provide accurate information and project plans and progress.Project management\n\u000044",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 44,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software EngineeringFigure 2.11 Project management responsibilities\n\u000045ProjectmanagementReporting\nAdministrationFigure 2.11 Project management responsibilitiesBudgetScheduleRisksProblemsProgress\nFinanceComplianceProcurementLiaisonVacationsAbsenceWork qualityReviewingHiringPeople",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 45,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•The best way to develop software products is to use agile software engineering methods that are geared to rapid product development and delivery.•Agile methods are based around iterative development and the minimization of overheads during the development process.•Extreme programming (XP) is an inﬂuential agile method that introduced agile development practices such as user stories, test-ﬁrst development and continuous integration. These are now mainstream software development activities.•Scrum is an agile method that focuses on agile planning and management. Unlike XP, it does not deﬁne the engineering practices to be used. The development team may use any technical practices that they believe are appropriate for the product being developed.•In Scrum, work to be done is maintained in a product backlog – a list of work items to be completed. Each increment of the software implements some of the work items from the product backlog.Key points 1\n\u000046",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 46,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Agile Software Engineering•Sprints are ﬁxed-time activities (usually 2–4 weeks) where a product increment is developed. Increments should be ‘potentially shippable’ i.e. they should not need further work before they are delivered.•A self-organizing team is a development team that organizes the work to be done by discussion and agreement amongst team members.•Scrum practices such as the product backlog, sprints and self-organizing teams can be used in any agile development process, even if other aspects of Scrum are not used.Key points 2\n\u000047",
    "metadata": {
      "deck_id": 18,
      "slide_id": 37,
      "page_number": 47,
      "title": "2. Agile Software Engineering.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/2. Agile Software Engineering.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software products",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 1,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•Add your introductory information about your course here\n\u00002",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 2,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•Software products are generic software systems that provide functionality that is useful to a range of customers.•Many different types of products are available from large-scale business systems (e.g. MS Excel) through personal products (e.g. Evernote) to simple mobile phone apps and games (e.g.  Suduko).•Software product engineering methods and techniques have evolved from software engineering techniques that support the development of one-off, custom software systems.•Custom software systems are still important for large businesses, government and public bodies. They are developed in dedicated software projects.Software products\n\u00003",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 3,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software ProductsFigure 1.1 Project-based software engineering\n\u00004ProblemRequirementsSoftwareCUSTOMER\nCUSTOMER andDEVELOPERDEVELOPERimplemented-byhelps-withgeneratesFigure 1.1 Project-based software engineering",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 4,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•The starting point for the software development is a set of ‘software requirements’ that are owned by an external client and which set out what they want a software system to do to support their business processes.•The software is developed by a software company (the contractor) who design and implement a system that delivers functionality to meet the requirements.•The customer may change the requirements at any time in response to business changes (they usually do). The contractor must change the software to reﬂect these requirements changes.•Custom software usually has a long-lifetime (10 years or more) and it must be supported over that lifetime.Project-based software engineering\n\u00005",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 5,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software ProductsFigure 1.2 Product software engineering\n\u00006OpportunityProductfeaturesSoftwareDEVELOPER\nDEVELOPERDEVELOPERimplemented-byrealizesinspiresFigure 1.2 Product software engineering",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 6,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•The starting point for product development is a business opportunity that is identiﬁed by individuals or a company. They develop a software product to take advantage of this opportunity and sell this to customers.•The company who identiﬁed the opportunity design and implement a set of software features that realize the opportunity and that will be useful to customers.•The software development company are responsible for deciding on the development timescale, what features to include and when the product should change. •Rapid delivery of software products is essential to capture the market for that type of product.Product software engineering\n\u00007",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 7,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software ProductsSoftware product line A set of software products that share a common core. Each member of the product line includes customer-speciﬁc adaptations and additions. Software product lines may be used to implement a custom system for a customer with speciﬁc needs that can’t be met by a generic product. Platform A software (or software+hardware) product that includes functionality so that new applications can be built on it. An example of a platform that you probably use is Facebook. It provides an extensive set of product functionality but also provides support for  creating ‘Facebook apps’.  These add new features that may be used by a business or a Facebook interest group.Table 1.1 Software product lines and platforms\n\u00008",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 8,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•Stand-alone  The software executes entirely on the customer’s computers.•Hybrid Part of the software’s functionality is implemented on the customer’s computer but some features are implemented on the product developer’s servers.•Software service All of the product’s features are implemented on the developer’s servers and the customer accesses these through a browser or a mobile app.Software execution models\n\u00009",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 9,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software ProductsFigure 1.3 Software execution models\n\u000010User’s computer\nVendor’s serversProduct updatesUser interfaceProduct functionalityUser dataUser’s computer\nAdditional functionalityUser data backupsProduct updatesUser interfacePartial functionalityUser dataUser’s computer\nProduct functionalityUser dataUser interface (browser or app)Stand-alone executionHybrid executionSoftware as a serviceFigure 1.3 Software execution models\nVendor’s serversVendor’s servers",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 10,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•The key feature of product development is that there is no external customer that generates requirements and pays for the software. This is also true for other types of software development:•Student projects Individuals or student groups develop software as part of their course. Given an assignment, they decide what features to include in the software.• Research software Researchers develop software to help them answer questions that are relevant to their research.•Internal tool development Software developers may develop tools to support their work - in essence, these are internal products that are not intended for customer release.Comparable software development\n\u000011",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 11,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•The starting point for software product development is a ‘product vision’.•Product visions are simple statements that deﬁne the essence of the product to be developed.•The product vision should answer three fundamental questions:•What is the product to be developed?•Who are the target customers and users?•Why should customers buy this product?The product vision\n\u000012",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 12,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•FOR (target customer)•WHO (statement of the need or opportunity)•The (PRODUCT NAME) is a (product category)•THAT (key beneﬁt, compelling reason to buy)•UNLIKE (primary competitive alternative)•OUR PRODUCT  (statement of primary differentiation)Moore’s vision template\n\u000013",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 13,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products“FOR a mid-sized company's marketing and sales departments WHO need basic CRM functionality, THE CRM-Innovator is a Web-based service THAT provides sales tracking, lead generation, and sales representative support features that improve customer relationships at critical touch points. UNLIKE other services or package software products, OUR product provides very capable services at a moderate cost.”Vision template example\n\u000014",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 14,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software ProductsDomain experience The product developers may work in a particular area (say marketing and sales) and understand the software support that they need. They may be frustrated by the deﬁciencies in the software they use and see opportunities for an improved system.Product experience Users of existing software (such as word processing software) may see simpler and better ways of providing comparable functionality and propose a new system that implements this. New products can take advantage of recent technological developments such as speech interfaces.Customer experience The software developers may have extensive discussions with prospective customers of the product to understand the problems that they face, constraints, such as interoperability, that limit their ﬂexibility to buy new software, and the critical attributes of the software that they need.Prototyping and playing around Developers may have an idea for software but need to develop a better understanding of that idea and what might be involved in developing it into a product. They may develop a prototype system as an experiment and ‘play around’ with ideas and variations using that prototype system as a platform.Table 1.2 Information sources for developing a product vision\n\u000015",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 15,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software ProductsFOR teachers and educators WHO need a way to help students use web-based learning resources and applications, THE iLearn system is an open learning environment THAT allows the set of resources used by classes and students to be easily conﬁgured for these students and classes by teachers themselves. UNLIKE Virtual Learning Environments, such as Moodle, the focus of iLearn is the learning process rather than the administration and management of materials, assessments and coursework. OUR product enables teachers to create subject and age-speciﬁc environments for their students using any web-based resources, such as videos, simulations and written materials that are appropriate. Schools and universities are the target customers for the iLearn system as it will signiﬁcantly improve the learning experience of students at relatively low cost. It will collect and process learner analytics that will reduce the costs of progress tracking and reporting.Table 1.3 A vision statement for the iLearn system\n\u000016",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 16,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•Software product management is a business activity that focuses on the software products developed and sold by the business.•Product managers (PMs) take overall responsibility for the product and are involved in planning, development and product marketing. •Product managers are the interface between the organization, its customers and the software development team. They are involved at all stages of a product’s lifetime from initial conception through to withdrawal of the product from the market.•Product managers must look outward to customers and potential customers rather than focus on the software being developed.Software product management\n\u000017",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 17,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software ProductsFigure 1.4 Product management concerns\n\u000018Business needs\nTechnologyconstraintsCustomerexperienceProductmanagerFigure 1.4 Product management concerns",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 18,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•Business needs  PMs have to ensure that the software being developed meets the business goals of the software development company.•Technology constraints PMs must make developers aware of technology issues that are important to customers.•Customer experience PMs should be in regular contact with customers and potential customers to understand what they are looking for in a product, the types of users and their backgrounds and the ways that the product may be used.Product management concerns\n\u000019",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 19,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software ProductsFigure 1.5 Technical interactions of product managers\n\u000020ProductmanagerUser interfacedesignProduct visionmanagementProduct backlog managementAcceptancetestingUser storiesand scenariosCustomertestingFigure 1.5 Technical interactions of product managers",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 20,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•Product vision management•The product manager may be responsible for helping with the development of the product vision. The should always be responsible for managing the vision, which involves assessing and evaluating proposed changes against the product vision. They should ensure that there is no ‘vision drift’•Product roadmap development•A product roadmap is a plan for the development, release and marketing of the software. The PM should lead roadmap development and should be the ultimate authority in deciding if changes to the roadmap should be made.•User story and scenario development•User stories and scenarios are used to reﬁne a product vision and identify product features. Based on his or her knowledge of customers, the PM should lead the development of stories and scenarios.Technical interactions of product managers\n\u000021",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 21,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•Product backlog creation and management•The product backlog is a prioritized ‘to-do’ list of what has to be developed. PMs should be involved in creating and reﬁning the backlog and deciding on the priority of product features to be developed.•Acceptance testing•Acceptance testing is the process of verifying that a software release meets the goals set out in the product roadmap and that the product is efﬁcient and reliable.  The PM should be involved in developing tests of the product features that reﬂect how customers use the product. •Customer testing•Customer testing involves taking a release of a product to customers and getting feedback on the product’s features, usability and business. PMs are involved in selecting customers to be involved in the customer testing process and working with them during that process. •User interface design•Product managers should understand user limitations and act as surrogate users in their interactions with the development team.  They should evaluate user interface features as they are developed to check that these features are not unnecessarily complex or force users to work in an unnatural way. Technical interactions of product managers\n\u000022",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 22,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•Product prototyping is the process of developing an early version of a product to test your ideas and to convince yourself and company funders that your product has real market potential.•You may be able to write an inspiring product vision, but your potential users can only really relate to your product when they see a working version of your software. They can point out what they like and don’t like about it and make suggestions for new features.•A prototype may be also used to help identify fundamental software components or services and to test technology. •Building a prototype should be the ﬁrst thing that you do when developing a software product. Your aim should be to have a working version of your software that can be used to demonstrate its key features.  •You should always plan to throw-away the prototype after development and to re-implement the software, taking account of issues such as security and reliability.Product prototyping\n\u000023",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 23,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•Feasibility demonstration You create an executable system that demonstrates the new ideas in your product. The aims at this stage are to see if your ideas actually work and to show funders and/or company management the original product features that are better than those in competing products.•Customer demonstration You take an existing prototype created to demonstrate feasibility and extend this with your ideas for speciﬁc customer features and how these can be realized. Before you develop this type of prototype, you need to do some user studies and have a clearer idea of your potential users and scenarios of use.Two-stage prototyping\n\u000024",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 24,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•Software products are software systems that include general functionality that is likely to be useful to a wide range of customers. •In product software engineering, the same company is responsible for deciding on the features that should be part of the product and the implementation of these features.•Software products may be delivered as stand-alone systems running on the customer’s computers, hybrid systems or service-based systems. In hybrid systems, some features are implemented locally and others are accessed over the Internet.  All product features are remotely accessed in service-based products.•A product vision should succinctly describe what is to be developed, who are the target customers for the product and why they should buy the product that you are developing.•Domain experience, product experience, customer experience and an experimental software prototype may all contribute to the development of the product vision.Key points 1\n\u000025",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 25,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Software Products•Key responsibilities of product managers are product vision ownership, product roadmap development, creating user stories and the product backlog, customer and acceptance testing and user interface design.•Product managers work at the interface between the business, the software development team and the product customers. They facilitate communications between these groups.•You should always develop a product prototype to reﬁne your own ideas and to demonstrate the planned product features to potential customersKey points 2\n\u000026",
    "metadata": {
      "deck_id": 18,
      "slide_id": 38,
      "page_number": 26,
      "title": "1. Software Products.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/1. Software Products.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018Chapter 6Microservices architecture",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 1,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•A software service is a software component that can be accessed from remote computers over the Internet. Given an input, a service produces a corresponding output, without side effects.  •The service is accessed through its published interface and all details of the service implementation are hidden. •Services do not maintain any internal state. State information is either stored in a database or is maintained by the service requestor. •When a service request is made, the state information may be included as part of the request and the updated state information is returned as part of the service result. •As there is no local state, services can be dynamically reallocated from one virtual server to another and replicated across several servers.Software services\n\u00002",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 2,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•After various experiments in the 1990s with service-oriented computing, the idea of ‘big’ Web Services emerged in the early 2000s. •These were based on XML-based protocols and standards such as SOAP for service interaction and WSDL for interface description.•Most software services don’t need the generality that’s inherent in the design of web service protocols. •Consequently, modern service-oriented systems, use simpler, ‘lighter weight’ service-interaction protocols that have lower overheads and, consequently, faster execution.Modern web services\n\u00003",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 3,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•Microservices are small-scale, stateless, services that have a single responsibility. They are combined to create applications.•They are completely independent with their own database and UI management code.•Software products that use microservices have a microservices architecture. •If you need  to create cloud-based software products that are adaptable, scaleable and resilient then I recommend that design them around a microservices architecture.Microservices\n\u00004",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 4,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•System authentication•User registration, where users provide information about their identity, security information, mobile (cell) phone number and email address.•Authentication using UID/password.•Two-factor authentication using code sent to mobile phone.•User information management e.g. change password or mobile phone number.•Reset forgotten password.•Each of these features could be implemented as a separate service that uses a central shared database to hold authentication information.•However, these features are too large to be microservices. To identify the microservices that might be used in the authentication system, you need to break down the coarse-grain features into more detailed functions. A microservice example\n\u00005",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 5,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.1 Functional breakdown of authentication features\n\u00006User registrationSetup new login idSetup new passwordSetup password recovery informationSetup two-factor authenticationConfirm registrationAuthenticate using UID/passwordGet login idGet passwordCheck credentialsConfirm authenticationFigure 6.1 Functional breakdown of authentication features",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 6,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.2 Authentication microservices\n\u00007UID managementPasswordmanagementUser infomanagementUID dataPassword dataUser dataAuthenticationFigure 6.2 Authentication microservices",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 7,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureSelf-contained Microservices do not have external dependencies. They manage their own data and implement their own user interface.Lightweight Microservices communicate using lightweight protocols, so that service communication overheads are low.Implementation-independent Microservices may be implemented using different programming languages and may use different technologies (e.g. different types of database) in their implementation.Independently deployable Each microservice runs in its own process and is independently deployable, using automated systems.Business-oriented Microservices should implement business capabilities and needs, rather than simply provide a technical service.Table 6.1 Characteristics of microservices\n\u00008",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 8,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•Microservices communicate by exchanging messages. •A message that is sent between services includes some administrative information, a service request and the data required to deliver the requested service. •Services return a response to service request messages.•An authentication service may send a message to a login service that includes the name input by the user. •The response may be a token associated with a valid user name or might be an error saying that there is no registered user.Microservice communication\n\u00009",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 9,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•A well-designed microservice should have high cohesion and low coupling.•Cohesion is a measure of the number of relationships that parts of a component have with each other. High cohesion means that all of the parts that are needed to deliver the component’s functionality are included in the component. •Coupling is a measure of the number of relationships that one component has with other components in the system. Low coupling means that components do not have many relationships with other components. •Each  microservice should have a single responsibility i.e. it should do one thing only and it should do it well.  •However, ‘one thing only’ is difﬁcult to deﬁne  in a way that’s applicable to all services.•Responsibility does not always mean a single, functional activity. Microservice characteristics\n\u000010",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 10,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.3 Password management functionality\n\u000011Figure 6.3 Password management functionalityUser functionsCreate passwordChange passwordCheck passwordRecover passwordSupporting functionsCheck password validityDelete password Backup password databaseRecover password databaseCheck database integrityRepair password DB",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 11,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.4 Microservice support code\n\u000012Microservice X Service functionality  Message management UI implementation  Failuremanagement Data consistencymanagementFigure 6.4 Microservice support code",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 12,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•A microservices architecture is an architectural style –  a tried and tested way of implementing a logical software architecture.   •This architectural style addresses two problems with monolithic applications•The whole system has to be rebuilt, re-tested and re-deployed when any change is made. This can be a slow process as changes to one part of the system can adversely affect other components.  •As the demand on the system increases, the whole system has to be scaled, even if the demand is localized to a small number of system components that implement the most popular system functions. Microservices architecture\n\u000013",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 13,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•Microservices are self-contained and run in separate processes. •In cloud-based systems, each microservice may be deployed in its own container. This means a microservice can be stopped and restarted without affecting other parts of the system. •If the demand on a service increases, service replicas can be quickly created and deployed. These do not require a more powerful server so ‘scaling-out’ is, typically, much cheaper than ’scaling up’.•Beneﬁts of microservices architecture\n\u000014",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 14,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureImagine that you are developing a photo printing service for mobile devices. Users can upload photos to your server from their phone or specify photos from their Instagram account that they would like to be printed. Prints can be made at different sizes and on different media. Users can chose print size and print medium. For example, they may decide to print a picture onto a mug or a T-shirt. The prints or other media are prepared and then posted to their home. They pay for prints either using a payment service such as Android or Apple Pay or by registering a credit card with the printing service provider.Table 6.2 A photo printing system for mobile devices\n\u000015",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 15,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.5 A microservices architecture for a photo printing system\n\u000016Mobile appAPI gatewayAuthenticationFigure 6.5 A microservices architecture for a photo printing systemSERVICESRegistrationUploadPaymentPrintingDespatch",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 16,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.6 Microservices architecture - key design questions\n\u000017What are the microservices that make up the system?How should microservices communicate with each other?\nHow should the microservices in the system be coordinated?How should service failure be detected, reported and managed?How should data be distributed and shared?MicroservicesarchitecturedesignFigure 6.6 Microservices architecture - key design questions",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 17,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•Balance ﬁne-grain functionality and system performance•Single-function services mean that changes are limited to fewer services  but require service communications to implement user functionality. This slows down a system because of the need for each service to bundle and unbundle messages sent from other services.•Follow the ‘common closure principle’•Elements of a system that are likely to be changed at the same time should be located within the same service. Most new and changed requirements should therefore only affect a single service.•Associate services with business capabilities •A business capability is a discrete area of business functionality that is the responsibility of an individual or a group. You should identify the services that are required to support each business capability.•Design services so that they only have access to the data that they need•If there is an overlap between the data used by different services, you need a mechanism to propagate data changes to all services using the same data. Decomposition guidelines\n\u000018",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 18,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•Services communicate by exchanging messages that include  information about the originator of the message, as well as the data that is the input to or output from the request.•When you are designing a microservices architecture, you have to establish a standard for communications that all microservices should follow.  Some of the key decisions that you have to make are•should service interaction be synchronous or asynchronous?•should services communicate directly or via message broker middleware?•what protocol should be used for messages exchanged between services?Service communications\n\u000019",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 19,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.7 Synchronous and asynchronous microservice interaction\n\u000020Service AFigure 6.7 Synchronous and asynchronous microservice interaction\nCallsReturns\nRequests (B)Synchronous - A waits for B\nAsynchronous - A and B execute concurrently\nQueue BQueue ARequests (A)Service BService AProcessingWaitingProcessingProcessingProcessing\nProcessingProcessing\nProcessingProcessingService B",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 20,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•In a synchronous interaction, service A issues a request to service B. Service A then suspends processing while B is processing the request. •It waits until service B has returned the required information before continuing execution.•In an asynchronous interaction, service A issues the request that is queued for processing by service B. A then continues processing without waiting for B to ﬁnish its computations. •Sometime later, service B completes the earlier request from service A and queues the result to be retrieved by A. •Service A, therefore, has to check its queue periodically to see if a result is available.•Synchronous and asynchronous interaction\n\u000021",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 21,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.8 Direct and indirect service communication\n\u000022Figure 6.8 Direct and indirect service communicationDirect communication - A and B send messages to each other\nIndirect communication - A and B communicate through a message brokerMessage brokerService AService B\nService AService B",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 22,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•Direct service communication requires that interacting services know each other’s address. •The services interact by sending requests directly to these addresses.•Indirect communication involves naming the service that is required and sending that request to a message broker (sometimes called a message bus). •The message broker is then responsible for ﬁnding the service that can fulﬁl the service request.Direct and indirect service communication\n\u000023",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 23,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•You should isolate data within each system service with as little data sharing as possible.•If data sharing is unavoidable, you should design microservices so that most sharing is ‘read-only’, with a minimal number of services responsible for data updates.•If services are replicated in your system, you must include a mechanism that can keep the database copies used by replica services consistent.Microservice data design\n\u000024",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 24,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•An ACID transaction bundles a set of data updates into a single unit so that either all updates are completed or none of them are. ACID transactions are impractical in a microservices architecture.•The databases used by different microservices or microservice replicas need not be completely consistent all of the time.  •Dependent data inconsistency •The actions or failures of one service can cause the data managed by another service to become inconsistent.•Replica inconsistency•There are several replicas of the same service that are executing concurrently. These all have their own database copy and each updates its own copy of the service data. You need a way of making these databases ‘eventually consistent’ so that all replicas are working on the same data.Inconsistency management\n\u000025",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 25,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•Eventual consistency is a situation where the system guarantees that the databases will eventually become consistent.   •You can implement eventual consistency by maintaining a transaction log. •When a database change is made, this is recorded on a ‘pending updates’ log. •Other service instances look at this log, update their own database and indicate that they have made the change. Eventual consistency\n\u000026",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 26,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.9 Using a pending transaction log\n\u000027Pending transactions logA1/DB update 1A1/DB update 2A2/DB update 1Figure 6.9 Using a pending transactions logService A1Database AService A2Database A",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 27,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•Most user sessions involve a series of interactions in which operations have to be carried out in a speciﬁc order.  •This is called a workﬂow. •An authentication workﬂow for UID/password authentication shows the steps involved in authenticating a user.•In this example, the user is allowed 3 login attempts before the system indicates that the login has failed.Service coordination\n\u000028",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 28,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.10 Authentication workﬂow\n\u000029EndRetryloginGet loginStart\nEndCheck login\nGet passwordCheck passwordIndicate failure\nlogin OKlogin invalid\npassword OKpassword invalidattempts > 3\nattempts = 1authfail = F\nauthfail=TFigure 6.10 Authentication workflow\nauthfail = FIncrementattemptsattempts <= 3\nauthfail = Tauthfail=F",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 29,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.11 Orchestration and choreography\n\u000030Authentication controllerService orchestrationService choreographyFigure 6.11 Orchestration and choreography \nAuthentication eventsLogin servicePasswordserviceLogin servicePasswordservice",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 30,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureInternal service failure These are conditions that are detected by the service and can be reported to the service client in an error message. An example of this type of failure is a service that takes a URL as an input and discovers that this is an invalid link.External service failure These failures have an external cause, which affects the availability of a service. Failure may cause the service to become unresponsive and actions have to be taken to restart the service.Service performance failure The performance of the service degrades to an unacceptable level. This may be due to a heavy load or an internal problem with the service. External service monitoring can be used to detect performance failures and unresponsive services.Table 6.3 Failure types in a microservices system\n\u000031",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 31,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•A timeout is a counter that this associated with the service requests and starts running when the request is made. •Once the counter reaches some predeﬁned value, such as 10 seconds, the calling service assumes that the service request has failed and acts accordingly.•The problem with the timeout approach is that every service call to a ‘failed service’ is delayed by the timeout value so the whole system slows down. •Instead of using timeouts explicitly when a service call is made, he suggests using a circuit breaker. Like an electrical circuit breaker, this immediately denies access to a failed service without the delays associated with timeouts.Timeouts and circuit breakers\n\u000032",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 32,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.12 Using a circuit breaker to cope with service failure\n\u000033Circuit breakerCheck S2 availabilityretries>3 retries<=3 \ntimeout oktimeout failS2 availableS2 unavailableFigure 6.12 Using a circuit breaker to cope with service failureService S1Service S2Set timeoutRoute service requestRespond S2 unavailableSet S2 unavailableRoute service responseIncrement retriesCheck timeout",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 33,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•The REST (REpresentational State Transfer) architectural style is based on the idea of transferring representations of digital resources from a server to a client. •You can think of a resource as any chunk of data such as credit card details, an individual’s medical record, a magazine or newspaper, a library catalogue, and so on.•Resources are accessed via their unique URI and RESTful services operate on these resources.•This is the fundamental approach used in the web where the resource is a page to be displayed in the user’s browser. •An HTML representation is generated by the server in response to an HTTP GET request and is transferred to the client for display by a browser or a special-purpose app.RESTful services\n\u000034",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 34,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureUse HTTP verbs The basic methods deﬁned in the HTTP protocol (GET, PUT,  POST,  DELETE) must be used to access the operations made available by the service.Stateless services Services must never maintain internal state. As I have already explained, microservices are stateless so ﬁt with this principle.URI addressable All resources must have a URI, with a hierarchical structure, that is used to access sub-resources.Use XML or JSON Resources should normally be represented in JSON or XML or both. Other representations, such as audio and video representations, may be used if appropriate.Table 6.4 RESTful service principles\n\u000035",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 35,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureCreate Implemented using HTTP POST, which creates the resource with the given URI. If the resource has already been created, an error is returned.Read Implemented using HTTP GET, which reads the resource and returns its value. GET operations should never update a resource so that successive GET operations with no intervening PUT operations always return the same value.Update Implemented using HTTP PUT, which modiﬁes an existing resource. PUT should not be used for resource creation.Delete Implemented using HTTP DELETE, which makes the resource inaccessible using the speciﬁed URI. The resource may or may not be physically deleted.Table 6.5 RESTful service operations\n\u000036",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 36,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•Imagine a system that maintains information about incidents, such as trafﬁc delays, roadworks and accidents on a national road network. This system can be accessed via a browser using the URL:•https://trafﬁcinfo.net/incidents/•Users can query the system to discover incidents on the roads on which they are planning to travel.•When implemented as a RESTful web service, you need to design the resource structure so that incidents are organized hierarchically. •For example, incidents may be recorded according to the road identiﬁer (e.g. A90), the location (e.g. stonehaven), the carriageway direction (e.g. north) and an incident number (e.g. 1).  Therefore, each incident can be accessed using its URI:•https://trafﬁcinfo.net/incidents/A90/stonehaven/north/1Road information system\n\u000037",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 37,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureIncident ID: A90N17061714391Date: 17 June 2017Time reported: 1439Severity: SigniﬁcantDescription: Broken-down bus on north carriageway. One lane closed. Expect delays of up to 30 minutesTable 6.6 Incident description\n\u000038",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 38,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•Retrieve•Returns information about a reported incident or incidents. Accessed using the GET verb.•Add•Adds information about a new incident. Accessed using the POST verb.•Update•Updates the information about a reported incident. Accessed using the PUT verb.•Delete•Deletes an incident. The DELETE verb is used when an incident has been cleared.Service operations\n\u000039",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 39,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.13 HTTP request and response processing\n\u000040HTTP request\nHTTP responseService actionsMicroserviceFigure 6.13 HTTP request and response processingRequest processing\nResponse generation",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 40,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.14 HTTP request and response message organization\n\u000041 [Request header] [Request body]REQUEST[HTTP verb][URI][HTTP version]Figure 6.14 HTTP request and response message organisation [Response header] [Response body]RESPONSE[Response code][HTTP version]",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 41,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureJSON{ id: “A90N17061714391”, “date”: “20170617”, “time”: “1437”, “road_id”: “A90”, “place”: “Stonehaven”, “direction”: “north”, “severity”: “signiﬁcant”, “description”: “Broken-down bus on north carriageway. One lane closed. Expect delays of up to 30 minutes.” }Table 6.7 XML and JSON descriptions\n\u000042",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 42,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureXML<id> A90N17061714391 </id> <date> 20170617 </date> <time> 1437 </time> … <description>Broken-down bus on north carriageway. One lane closed. Expect delays of up to 30 minutes. </description>Table 6.7 XML and JSON descriptions\n\u000043",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 43,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.15 A GET request and the associated response\n\u000044REQUESTGETHTTP/1.1...Content-Length: 461Content-Type: text/jsonRESPONSEHTTP/1.1Figure 6.15 A GET request and the associated response200incidents/A90/stonehaven/Host: trafficinfo.net...Accept: text/json, text/xml, text/plainContent-Length: 0{   “number”: “A90N17061714391”,   “date”: “20170617”,   “time”: “1437”,  “road_id”: “A90”,  “place”: “Stonehaven”,  “direction”: “north”,  “severity”: “significant”,  “description”: “Broken-down bus on north     carriageway. One lane closed. Expect delays of up to 30 minutes.”}{   “number”: “A90S17061713001”,   “date”: “20170617”,   “time”: “1300”,  “road_id”: “A90”,  “place”: “Stonehaven”,  “direction”: “south”,  “severity”: “minor”,  “description”: “Grass cutting on verge. Minor delays”}",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 44,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•After a system has been developed and delivered, it has to be deployed on servers, monitored for problems and updated as new versions become available. •When a system is composed of tens or even hundreds of microservices, deployment of the system is more complex than for monolithic systems.• The service development teams decide which programming language, database, libraries and other support software should be used to implement their service. Consequently, there is no ‘standard’ deployment conﬁguration for all services. •It is now normal practice for microservice development teams to be responsible for deployment and service management as well as software development and to use continuous deployment.•Continuous deployment means that as soon as a change to a service has been made and validated, the modiﬁed service is redeployed. Service deployment\n\u000045",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 45,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•Continuous deployment depends on automation so that as soon as a change is committed, a series of automated activities is triggered to test the software. •If the software ‘passes’ these tests, it then enters another automation pipeline that packages and deploys the software.•The deployment of a new service version starts with the programmer committing the code changes to a code management system such as Git. •This triggers a set of automated tests that run using the modiﬁed service. If all service tests run successfully, a new version of the system that incorporates the changed service is created. •Another set of automated system tests are then executed. If these run successfully, the service is ready for deployment.Deployment automation\n\u000046",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 46,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.16 A continuous deployment pipeline\n\u000047Commit change to version manage-mentTriggerspassReject changeReject changeReject change\nReject changepasspassfail\nfailfailFigure 6.16 A continuous deployment pipeline\nRun unit testsContainerize serviceRun integration testsBuild test systemReplace current serviceDeploy service containerRun acceptance testsfailpass",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 47,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architectureFigure 6.17 Versioned services\n\u000048API gatewaycameras service request for cameras serviceFigure 6.17 Versioned servicescurrent version linkservice responsecameras service responsemonitor responseService monitor\ncameras 001cameras 002",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 48,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•A microservice is an independent and self-contained software component that runs in its own process and communicates with other microservices using lightweight protocols.•Microservices in a system can be implemented using different programming languages and database technologies.•Microservices have a single responsibility and should be designed so that they can be easily changed without having to change other microservices in the system.•Microservices architecture is an architectural style in which the system is constructed from communicating microservices. It is well-suited to cloud based systems where each microservice can run in its own container.•The two most important responsibilities of architects of a microservices system are to decide how to structure the system into microservices and to decide how microservices should communicate and be coordinated.Key points 1\n\u000049",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 49,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  },
  {
    "content": "© Ian Sommerville 2018:Microservices architecture•Communication and coordination decisions include deciding on microservice communication protocols, data sharing, whether services should be centrally coordinated, and failure management. •The RESTful architectural style is widely used in microservice-based systems. Services are designed so that the HTTP verbs, GET, POST, PUT and DELETE, map onto the service operations.•The RESTful style is based on digital resources that, in a microservices architecture, may be represented using XML or, more commonly, JSON.•Continuous deployment is a process where new versions of a service are put into production as soon as a service change has been made. It is a completely automated process that relies on automated testing to check that the new version is of ‘production quality’.•If continuous deployment is used, you may need to maintain multiple versions of deployed services so that you can switch to an older version if problems are discovered in a newly-deployed service.•Key points 2\n\u000050",
    "metadata": {
      "deck_id": 18,
      "slide_id": 39,
      "page_number": 50,
      "title": "6. Microservices architecture.pdf",
      "file_path": "C:/Users/dell/Downloads/Ian Slides/LECTURES/6. Microservices architecture.pdf"
    }
  }
]